--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         49152 B, 64 B, 12-way associative
LL cache:         8388608 B, 64 B, 8-way associative
Command:          ./main
Data file:        cachegrind.out.10301
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      I1mr            ILmr           Dr                     D1mr                DLmr               Dw                   D1mw                DLmw               
--------------------------------------------------------------------------------
12,885,387,992 (100.0%) 14,732 (100.0%) 2,522 (100.0%) 4,138,911,749 (100.0%) 65,069,075 (100.0%) 1,116,610 (100.0%) 614,970,870 (100.0%) 10,558,121 (100.0%) 1,759,789 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr           ILmr         Dr                     D1mr                DLmr             Dw                   D1mw               DLmw              file:function
--------------------------------------------------------------------------------
6,363,723,776 (49.39%)    15 ( 0.10%)  15 ( 0.59%) 2,141,464,314 (51.74%)  1,169,939 ( 1.80%)   4,402 ( 0.39%)  44,236,136 ( 7.19%) 1,484,217 (14.06%)       0           /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/convolution.c:Conv2D
4,280,886,342 (33.22%)    21 ( 0.14%)  21 ( 0.83%) 1,408,822,362 (34.04%)  8,844,510 (13.59%)   2,225 ( 0.20%) 280,889,298 (45.68%)       198 ( 0.00%)      11 ( 0.00%)  /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/backprop.c:backprop_CNN_weight
  440,065,200 ( 3.42%)   943 ( 6.40%)  78 ( 3.09%)    80,609,639 ( 1.95%)    170,155 ( 0.26%)     434 ( 0.04%)  90,066,346 (14.65%) 2,786,545 (26.39%) 897,925 (51.02%)  ./malloc/./malloc/malloc.c:_int_malloc
  284,165,319 ( 2.21%)    29 ( 0.20%)  29 ( 1.15%)    81,160,973 ( 1.96%)  2,621,599 ( 4.03%) 535,317 (47.94%)  34,036,069 ( 5.53%)     9,915 ( 0.09%)   2,350 ( 0.13%)  ./malloc/./malloc/malloc.c:_int_free
  261,942,641 ( 2.03%)    54 ( 0.37%)  54 ( 2.14%)    38,554,642 ( 0.93%)  1,234,034 ( 1.90%)       0           14,711,952 ( 2.39%)   822,392 ( 7.79%) 188,545 (10.71%)  /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/convolution.c:max_pooling
  235,913,802 ( 1.83%)    47 ( 0.32%)  47 ( 1.86%)   102,123,533 ( 2.47%) 45,115,746 (69.34%)  42,789 ( 3.83%)  26,115,674 ( 4.25%)    13,169 ( 0.12%)   1,036 ( 0.06%)  /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/FC_layer.c:initialize_FC_layer
  168,670,072 ( 1.31%)    17 ( 0.12%)  17 ( 0.67%)    69,794,280 ( 1.69%)    552,325 ( 0.85%) 105,975 ( 9.49%)   2,701,800 ( 0.44%)   465,211 ( 4.41%)       8 ( 0.00%)  /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/backprop.c:backprop_max_pooling
  121,012,991 ( 0.94%)    15 ( 0.10%)  10 ( 0.40%)    23,761,774 ( 0.57%)      3,260 ( 0.01%)       0           11,475,729 ( 1.87%)    60,171 ( 0.57%)   5,264 ( 0.30%)  ./malloc/./malloc/malloc.c:calloc
   83,160,967 ( 0.65%)    14 ( 0.10%)  12 ( 0.48%)    14,621,667 ( 0.35%)  1,251,691 ( 1.92%)     264 ( 0.02%)  14,338,568 ( 2.33%)     7,892 ( 0.07%)       0           ./malloc/./malloc/malloc.c:malloc_consolidate
   68,960,256 ( 0.54%)     3 ( 0.02%)   3 ( 0.12%)    20,987,904 ( 0.51%)          0                0           11,993,088 ( 1.95%)         0                0           ./libio/./libio/iofread.c:fread
   68,366,360 ( 0.53%)     3 ( 0.02%)   3 ( 0.12%)    24,662,270 ( 0.60%)     95,560 ( 0.15%)     385 ( 0.03%)   5,620,531 ( 0.91%)         0                0           ./malloc/./malloc/malloc.c:unlink_chunk.constprop.0
   62,988,794 ( 0.49%)     3 ( 0.02%)   3 ( 0.12%)    22,905,016 ( 0.55%)    146,413 ( 0.23%)   9,433 ( 0.84%)  11,452,508 ( 1.86%)        76 ( 0.00%)       0           ./malloc/./malloc/malloc.c:free
   58,926,456 ( 0.46%)     5 ( 0.03%)   5 ( 0.20%)    12,460,464 ( 0.30%)    854,162 ( 1.31%)       0           10,911,996 ( 1.77%)         0                0           /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/backprop.c:backprop_CNN_bias
   56,999,376 ( 0.44%)     8 ( 0.05%)   8 ( 0.32%)    19,496,576 ( 0.47%)          0                0           11,995,040 ( 1.95%)         0                0           ./libio/./libio/fileops.c:_IO_file_xsgetn
   49,109,249 ( 0.38%)   873 ( 5.93%)   7 ( 0.28%)    13,329,900 ( 0.32%)     24,902 ( 0.04%)     129 ( 0.01%)   4,906,115 ( 0.80%)        43 ( 0.00%)       0           ./malloc/./malloc/malloc.c:malloc
   48,622,568 ( 0.38%)     8 ( 0.05%)   6 ( 0.24%)     3,450,428 ( 0.08%)         18 ( 0.00%)       0           11,544,084 ( 1.88%) 2,206,751 (20.90%) 585,617 (33.28%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms
   28,545,556 ( 0.22%)    10 ( 0.07%)   9 ( 0.36%)     6,319,292 ( 0.15%)    388,871 ( 0.60%) 348,949 (31.25%)   5,084,632 ( 0.83%)   252,953 ( 2.40%)      17 ( 0.00%)  /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/feature_map.c:padding_feature_map
   23,530,442 ( 0.18%)     5 ( 0.03%)   5 ( 0.20%)     5,472,428 ( 0.13%)    540,104 ( 0.83%)       0            4,642,900 ( 0.75%) 2,126,852 (20.14%)  22,467 ( 1.28%)  /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/convolution.c:Flatten
   22,592,554 ( 0.18%)    10 ( 0.07%)  10 ( 0.40%)     4,521,719 ( 0.11%)     13,623 ( 0.02%)  13,169 ( 1.18%)   3,014,472 ( 0.49%)    65,791 ( 0.62%)       2 ( 0.00%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
   22,001,439 ( 0.17%) 1,443 ( 9.80%)  54 ( 2.14%)    11,000,675 ( 0.27%)     13,645 ( 0.02%)      18 ( 0.00%)          24 ( 0.00%)         1 ( 0.00%)       1 ( 0.00%)  ???:???
   17,989,632 ( 0.14%)     1 ( 0.01%)   1 ( 0.04%)     7,495,680 ( 0.18%)          0                0            2,998,272 ( 0.49%)         0                0           ./libio/./libio/libioP.h:fread
   17,081,952 ( 0.13%)     3 ( 0.02%)   3 ( 0.12%)     5,999,472 ( 0.14%)      3,714 ( 0.01%)       0                3,904 ( 0.00%)         0                0           /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/load_file.c:load_feature_map_from_bin
   14,215,487 ( 0.11%)     3 ( 0.02%)   3 ( 0.12%)     8,625,968 ( 0.21%)    169,938 ( 0.26%)  41,108 ( 3.68%)   1,735,126 ( 0.28%)       418 ( 0.00%)       0           /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/feature_map.c:free_feature_map

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/backprop.c
--------------------------------------------------------------------------------
Ir                     I1mr        ILmr        Dr                     D1mr               DLmr             Dw                   D1mw             DLmw        

            .           .           .                      .                  .                .                    .                .           .           #include "main.h"
            .           .           .                      .                  .                .                    .                .           .           
            .           .           .                      .                  .                .                    .                .           .           float* backprop_CNN_bias(FEATURE_MAP matrix_gradient)
          468 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)           144 ( 0.00%)         0                0                  216 ( 0.00%)       0           0           {
          108 ( 0.00%)  0           0                      0                  0                0                   36 ( 0.00%)       0           0               float* bias_grad = (float*)calloc(matrix_gradient.channels, sizeof(float));
            .           .           .                      .                  .                .                    .                .           .           
        2,016 ( 0.00%)  0           0                      0                  0                0                    0                0           0               for (int c = 0; c < matrix_gradient.channels; c++)
            .           .           .                      .                  .                .                    .                .           .               {
       46,800 ( 0.00%)  0           0                      0                  0                0                    0                0           0                   for (int b = 0; b < matrix_gradient.batch_size; b++)
            .           .           .                      .                  .                .                    .                .           .                   {
    1,221,120 ( 0.01%)  0           0                      0                  0                0                    0                0           0                       for (int i = 0; i < matrix_gradient.height; i++)
            .           .           .                      .                  .                .                    .                .           .                       {
   33,509,376 ( 0.26%)  1 ( 0.01%)  1 ( 0.04%)             0                  0                0                    0                0           0                           for (int j = 0; j < matrix_gradient.width; j++)
            .           .           .                      .                  .                .                    .                .           .                           {
   24,146,244 ( 0.19%)  2 ( 0.01%)  2 ( 0.08%)    12,460,068 ( 0.30%)   854,090 ( 1.31%)       0           10,911,744 ( 1.77%)       0           0                               bias_grad[c] += matrix_gradient.fm_value[b][c][i][j];
            .           .           .                      .                  .                .                    .                .           .                           }
            .           .           .                      .                  .                .                    .                .           .                       }
            .           .           .                      .                  .                .                    .                .           .                   }
            .           .           .                      .                  .                .                    .                .           .               }
            .           .           .                      .                  .                .                    .                .           .           
            .           .           .                      .                  .                .                    .                .           .               return bias_grad;
          324 ( 0.00%)  0           0                    252 ( 0.00%)        72 ( 0.00%)       0                    0                0           0           }
            .           .           .                      .                  .                .                    .                .           .           
            .           .           .                      .                  .                .                    .                .           .           KERNEL backprop_CNN_weight(FEATURE_MAP input, FEATURE_MAP matrix_gradient, KERNEL kernel, int padding, int stride)
          612 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)           108 ( 0.00%)         0                0                  432 ( 0.00%)      36 ( 0.00%)  0           {
          270 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)            90 ( 0.00%)         0                0                  108 ( 0.00%)      54 ( 0.00%)  2 ( 0.00%)      input = (padding > 0) ? padding_feature_map(input, padding) : input;
           72 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)            36 ( 0.00%)        18 ( 0.00%)       0                    0                0           0               int weight_grad_size = kernel.size;
           72 ( 0.00%)  0           0                     36 ( 0.00%)         0                0                   36 ( 0.00%)      18 ( 0.00%)  1 ( 0.00%)      int weight_grad_channels = input.channels;
           72 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)            36 ( 0.00%)         0                0                   36 ( 0.00%)       0           0               int weight_grad_filters = kernel.filters;
           72 ( 0.00%)  0           0                     36 ( 0.00%)         0                0                   36 ( 0.00%)       0           0               int batch_size = input.batch_size;
          108 ( 0.00%)  0           0                      0                  0                0                   36 ( 0.00%)      36 ( 0.00%)  0               KERNEL output = init_kernel(weight_grad_size, weight_grad_channels, weight_grad_filters);
          108 ( 0.00%)  0           0                      0                  0                0                   36 ( 0.00%)       0           0               float **partial_sum = (float **)malloc((weight_grad_size) * sizeof(float *));
          360 ( 0.00%)  0           0                      0                  0                0                    0                0           0               for (int i = 0; i < weight_grad_size; i++)
            .           .           .                      .                  .                .                    .                .           .               {
          288 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)             0                  0                0                  144 ( 0.00%)       0           0                   partial_sum[i] = (float *)malloc((weight_grad_size) * sizeof(float));
            .           .           .                      .                  .                .                    .                .           .               }
            .           .           .                      .                  .                .                    .                .           .           
        1,980 ( 0.00%)  0           0                  1,440 ( 0.00%)         0                0                    0                0           0               for (int f = 0; f < weight_grad_filters; f++)
            .           .           .                      .                  .                .                    .                .           .               {
       18,252 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)        12,168 ( 0.00%)         0                0                  936 ( 0.00%)       0           0                   for (int c = 0; c < weight_grad_channels; c++)
            .           .           .                      .                  .                .                    .                .           .                   {
       31,392 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)         9,216 ( 0.00%)         0                0                    0                0           0                       for (int i = 0; i < weight_grad_size; i++)
            .           .           .                      .                  .                .                    .                .           .                       {
            .           .           .                      .                  .                .                    .                .           .                           for (int j = 0; j < weight_grad_size; j++)
            .           .           .                      .                  .                .                    .                .           .                           {
       22,176 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)        11,016 ( 0.00%)         0                0                5,544 ( 0.00%)       0           0                               partial_sum[i][j] = 0.0f;
            .           .           .                      .                  .                .                    .                .           .                           }
            .           .           .                      .                  .                .                    .                .           .                       }
      370,656 ( 0.00%)  0           0                123,552 ( 0.00%)         0                0                    0                0           0                       for (int b = 0; b < batch_size; b++)
            .           .           .                      .                  .                .                    .                .           .                       {
   12,399,264 ( 0.10%)  1 ( 0.01%)  1 ( 0.04%)     7,197,696 ( 0.17%)         0                0              119,808 ( 0.02%)       0           0                           for (int i = 0; i < matrix_gradient.height; i++)
            .           .           .                      .                  .                .                    .                .           .                           {
  228,851,712 ( 1.78%)  2 ( 0.01%)  2 ( 0.08%)   108,527,616 ( 2.62%)         0                0            2,359,296 ( 0.38%)       0           0                               for (int j = 0; j < matrix_gradient.width; j++)
            .           .           .                      .                  .                .                    .                .           .                               {
  594,542,592 ( 4.61%)  0           0             51,904,512 ( 1.25%)         0                0                    0                0           0                                   for (int m = 0; m < weight_grad_size; m++)
            .           .           .                      .                  .                .                    .                .           .                                   {
  943,718,400 ( 7.32%)  2 ( 0.01%)  2 ( 0.08%)   108,527,616 ( 2.62%)   329,304 ( 0.51%)       0                    0                0           0                                       for (int n = 0; n < weight_grad_size; n++)
            .           .           .                      .                  .                .                    .                .           .                                       {
            .           .           .                      .                  .                .                    .                .           .                                           // printf("m n: %d %d\n", m, n);
2,500,853,868 (19.41%)  1 ( 0.01%)  1 ( 0.04%) 1,132,462,152 (27.36%) 8,504,288 (13.07%)   2,225 ( 0.20%) 278,396,964 (45.27%)       0           0                                           partial_sum[m][n] += (input.fm_value[b][c][i * stride + m][j * stride + n] * matrix_gradient.fm_value[b][f][i][j]);
            .           .           .                      .                  .                .                    .                .           .                                       }
            .           .           .                      .                  .                .                    .                .           .                                   }
            .           .           .                      .                  .                .                    .                .           .                               }
            .           .           .                      .                  .                .                    .                .           .                           }
            .           .           .                      .                  .                .                    .                .           .                       }
       27,648 ( 0.00%)  0           0                  9,216 ( 0.00%)         0                0                    0                0           0                       for (int i = 0; i < weight_grad_size; i++) {
            .           .           .                      .                  .                .                    .                .           .                           for (int j = 0; j < weight_grad_size; j++) {
       45,072 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)        35,208 ( 0.00%)    10,828 ( 0.02%)       0                5,688 ( 0.00%)       0           0                               output.kernel_value[f][c][i][j] = partial_sum[i][j];
            .           .           .                      .                  .                .                    .                .           .                           }
            .           .           .                      .                  .                .                    .                .           .                       }
            .           .           .                      .                  .                .                    .                .           .                   }
            .           .           .                      .                  .                .                    .                .           .               }
          324 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)            36 ( 0.00%)         0                0                    0                0           0               for (int i = 0; i < weight_grad_size; i++)
            .           .           .                      .                  .                .                    .                .           .               {
          144 ( 0.00%)  0           0                     72 ( 0.00%)         0                0                   72 ( 0.00%)       0           0                   free(partial_sum[i]);
            .           .           .                      .                  .                .                    .                .           .               }
           72 ( 0.00%)  0           0                      0                  0                0                   36 ( 0.00%)       0           0               free(partial_sum);
            .           .           .                      .                  .                .                    .                .           .           
          108 ( 0.00%)  0           0                     36 ( 0.00%)         0                0                    0                0           0               if (padding > 0)
            .           .           .                      .                  .                .                    .                .           .               {
           36 ( 0.00%)  0           0                      0                  0                0                   18 ( 0.00%)       0           0                   free_feature_map(&input);
            .           .           .                      .                  .                .                    .                .           .               }
          180 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)           108 ( 0.00%)        54 ( 0.00%)       0                   72 ( 0.00%)      54 ( 0.00%)  8 ( 0.00%)      return output;
          432 ( 0.00%)  0           0                    360 ( 0.00%)        18 ( 0.00%)       0                    0                0           0           }
            .           .           .                      .                  .                .                    .                .           .           
            .           .           .                      .                  .                .                    .                .           .           // void update_weight_SGD(KERNEL* kernel, float learning_rate, KERNEL gradient_weight) {
            .           .           .                      .                  .                .                    .                .           .           //     for (int f = 0; f < kernel->filters; f++) {
            .           .           .                      .                  .                .                    .                .           .           //         for (int c = 0; c < kernel->channels; c++) {
            .           .           .                      .                  .                .                    .                .           .           //             for (int i = 0; i < kernel->size; i++) {
            .           .           .                      .                  .                .                    .                .           .           //                 for (int j = 0; j < kernel->size; j++) {
            .           .           .                      .                  .                .                    .                .           .           //                     kernel->kernel_value[f][c][i][j] -= (learning_rate * gradient_weight.kernel_value[f][c][i][j]);
            .           .           .                      .                  .                .                    .                .           .           //                 }
            .           .           .                      .                  .                .                    .                .           .           //             }
            .           .           .                      .                  .                .                    .                .           .           //         }
            .           .           .                      .                  .                .                    .                .           .           //     }
            .           .           .                      .                  .                .                    .                .           .           // }
            .           .           .                      .                  .                .                    .                .           .           
           22 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)             0                  0                0                   16 ( 0.00%)       0           0           float**** init_v_w(int size, int channels, int filters) {
            .           .           .                      .                  .                .                    .                .           .               // Kiểm tra tham số đầu vào
           16 ( 0.00%)  0           0                      0                  0                0                    0                0           0               if (size <= 0 || channels <= 0 || filters <= 0) {
            .           .           .                      .                  .                .                    .                .           .                   printf("Error: Invalid dimensions in init_v_w (size=%d, channels=%d, filters=%d)\n", size, channels, filters);
            .           .           .                      .                  .                .                    .                .           .                   return NULL;
            .           .           .                      .                  .                .                    .                .           .               }
            .           .           .                      .                  .                .                    .                .           .           
            .           .           .                      .                  .                .                    .                .           .               // Cấp phát cấp 1: mảng con trỏ 3 cấp
            8 ( 0.00%)  0           0                      2 ( 0.00%)         0                0                    4 ( 0.00%)       0           0               float**** v_w = (float****)malloc(filters * sizeof(float***));
            4 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0                0                    0                0           0               if (v_w == NULL) {
            .           .           .                      .                  .                .                    .                .           .                   printf("Error: Failed to allocate v_w\n");
            .           .           .                      .                  .                .                    .                .           .                   return NULL;
            .           .           .                      .                  .                .                    .                .           .               }
            .           .           .                      .                  .                .                    .                .           .           
            .           .           .                      .                  .                .                    .                .           .               // Cấp phát các cấp con trỏ
          104 ( 0.00%)  0           0                     78 ( 0.00%)         0                0                    0                0           0               for (int f = 0; f < filters; f++) {
          188 ( 0.00%)  0           0                     54 ( 0.00%)         0                0                  132 ( 0.00%)       2 ( 0.00%)  2 ( 0.00%)          v_w[f] = (float***)malloc(channels * sizeof(float**));
          286 ( 0.00%)  0           0                    208 ( 0.00%)         0                0                   26 ( 0.00%)       0           0                   if (v_w[f] == NULL) {
            .           .           .                      .                  .                .                    .                .           .                       // Giải phóng bộ nhớ đã cấp phát
            .           .           .                      .                  .                .                    .                .           .                       for (int i = 0; i < f; i++) {
            .           .           .                      .                  .                .                    .                .           .                           for (int c = 0; c < channels; c++) {
            .           .           .                      .                  .                .                    .                .           .                               for (int s = 0; s < size; s++) {
            .           .           .                      .                  .                .                    .                .           .                                   free(v_w[i][c][s]);
            .           .           .                      .                  .                .                    .                .           .                               }
            .           .           .                      .                  .                .                    .                .           .                               free(v_w[i][c]);
            .           .           .                      .                  .                .                    .                .           .                           }
            .           .           .                      .                  .                .                    .                .           .                           free(v_w[i]);
            .           .           .                      .                  .                .                    .                .           .                       }
            .           .           .                      .                  .                .                    .                .           .                       free(v_w);
            .           .           .                      .                  .                .                    .                .           .                       printf("Error: Failed to allocate v_w[%d]\n", f);
            .           .           .                      .                  .                .                    .                .           .                       return NULL;
            .           .           .                      .                  .                .                    .                .           .                   }
            .           .           .                      .                  .                .                    .                .           .           
          832 ( 0.00%)  0           0                    624 ( 0.00%)         0                0                    0                0           0                   for (int c = 0; c < channels; c++) {
        1,462 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)           416 ( 0.00%)         0                0                  834 ( 0.00%)      12 ( 0.00%) 12 ( 0.00%)              v_w[f][c] = (float**)malloc(size * sizeof(float*));
          832 ( 0.00%)  0           0                      0                  0                0                    0                0           0                       if (v_w[f][c] == NULL) {
            .           .           .                      .                  .                .                    .                .           .                           // Giải phóng bộ nhớ đã cấp phát
            .           .           .                      .                  .                .                    .                .           .                           for (int i = 0; i < f; i++) {
            .           .           .                      .                  .                .                    .                .           .                               for (int c2 = 0; c2 < channels; c2++) {
            .           .           .                      .                  .                .                    .                .           .                                   for (int s = 0; s < size; s++) {
            .           .           .                      .                  .                .                    .                .           .                                       free(v_w[i][c2][s]);
            .           .           .                      .                  .                .                    .                .           .                                   }
            .           .           .                      .                  .                .                    .                .           .                                   free(v_w[i][c2]);
            .           .           .                      .                  .                .                    .                .           .                               }
-- line 141 ----------------------------------------
-- line 148 ----------------------------------------
            .           .           .                      .                  .                .                    .                .           .                               free(v_w[f][c2]);
            .           .           .                      .                  .                .                    .                .           .                           }
            .           .           .                      .                  .                .                    .                .           .                           free(v_w[f]);
            .           .           .                      .                  .                .                    .                .           .                           free(v_w);
            .           .           .                      .                  .                .                    .                .           .                           printf("Error: Failed to allocate v_w[%d][%d]\n", f, c);
            .           .           .                      .                  .                .                    .                .           .                           return NULL;
            .           .           .                      .                  .                .                    .                .           .                       }
            .           .           .                      .                  .                .                    .                .           .           
          912 ( 0.00%)  0           0                      0                  0                0                    0                0           0                       for (int s = 0; s < size; s++) {
        1,522 ( 0.00%)  0           0                      0                  0                0                  608 ( 0.00%)       0           0                           v_w[f][c][s] = (float*)malloc(size * sizeof(float));
          608 ( 0.00%)  0           0                      0                  0                0                    0                0           0                           if (v_w[f][c][s] == NULL) {
            .           .           .                      .                  .                .                    .                .           .                               // Giải phóng bộ nhớ đã cấp phát
            .           .           .                      .                  .                .                    .                .           .                               for (int i = 0; i < f; i++) {
            .           .           .                      .                  .                .                    .                .           .                                   for (int c2 = 0; c2 < channels; c2++) {
            .           .           .                      .                  .                .                    .                .           .                                       for (int s2 = 0; s2 < size; s2++) {
            .           .           .                      .                  .                .                    .                .           .                                           free(v_w[i][c2][s2]);
            .           .           .                      .                  .                .                    .                .           .                                       }
            .           .           .                      .                  .                .                    .                .           .                                       free(v_w[i][c2]);
            .           .           .                      .                  .                .                    .                .           .                                   }
-- line 166 ----------------------------------------
-- line 174 ----------------------------------------
            .           .           .                      .                  .                .                    .                .           .                               }
            .           .           .                      .                  .                .                    .                .           .                               free(v_w[f]);
            .           .           .                      .                  .                .                    .                .           .                               free(v_w);
            .           .           .                      .                  .                .                    .                .           .                               printf("Error: Failed to allocate v_w[%d][%d][%d]\n", f, c, s);
            .           .           .                      .                  .                .                    .                .           .                               return NULL;
            .           .           .                      .                  .                .                    .                .           .                           }
            .           .           .                      .                  .                .                    .                .           .                           // Khởi tạo giá trị ngay khi cấp phát
            .           .           .                      .                  .                .                    .                .           .                           for (int j = 0; j < size; j++) {
          946 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)            26 ( 0.00%)         0                0                  306 ( 0.00%)       0           0                               v_w[f][c][s][j] = 0.0f;
            .           .           .                      .                  .                .                    .                .           .                           }
            .           .           .                      .                  .                .                    .                .           .                       }
            .           .           .                      .                  .                .                    .                .           .                   }
            .           .           .                      .                  .                .                    .                .           .               }
            .           .           .                      .                  .                .                    .                .           .               return v_w;
           18 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)            16 ( 0.00%)         0                0                    0                0           0           }
            .           .           .                      .                  .                .                    .                .           .           
           20 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0                0                   16 ( 0.00%)       0           0           void free_v_w(float**** v_w, int size, int channels, int filters) {
          104 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)            26 ( 0.00%)         0                0                    2 ( 0.00%)       0           0               for (int f = 0; f < filters; f++) {
          754 ( 0.00%)  0           0                     26 ( 0.00%)         0                0                    0                0           0                   for (int c = 0; c < channels; c++) {
        1,744 ( 0.00%)  0           0                      0                  0                0                    0                0           0                       for (int s = 0; s < size; s++) {
        1,216 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)           912 ( 0.00%)        90 ( 0.00%)      85 ( 0.01%)         304 ( 0.00%)       0           0                           free((v_w)[f][c][s]);
            .           .           .                      .                  .                .                    .                .           .                       }
          624 ( 0.00%)  0           0                    416 ( 0.00%)         0                0                  208 ( 0.00%)       0           0                       free((v_w)[f][c]);
            .           .           .                      .                  .                .                    .                .           .                   }
           52 ( 0.00%)  0           0                     26 ( 0.00%)         0                0                   26 ( 0.00%)       0           0                   free((v_w)[f]);
            .           .           .                      .                  .                .                    .                .           .               }
            4 ( 0.00%)  0           0                      2 ( 0.00%)         0                0                    0                0           0               free(v_w);
           14 ( 0.00%)  0           0                     12 ( 0.00%)         0                0                    0                0           0           }
            .           .           .                      .                  .                .                    .                .           .           
          324 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)            36 ( 0.00%)         0                0                  252 ( 0.00%)       0           0           void update_weight_SGD(KERNEL* kernel, KERNEL gradient_weight_avg, float learning_rate, float momentum, float**** v_w) {
          180 ( 0.00%)  0           0                     36 ( 0.00%)         0                0                    0                0           0               if (kernel == NULL || kernel->kernel_value == NULL) {
            .           .           .                      .                  .                .                    .                .           .                   printf("Error: kernel or kernel->kernel_value is NULL\n");
            .           .           .                      .                  .                .                    .                .           .                   return;
            .           .           .                      .                  .                .                    .                .           .               }
           72 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0                0                    0                0           0               if (gradient_weight_avg.kernel_value == NULL) {
            .           .           .                      .                  .                .                    .                .           .                   printf("Error: gradient_weight_avg.kernel_value is NULL\n");
            .           .           .                      .                  .                .                    .                .           .                   return;
            .           .           .                      .                  .                .                    .                .           .               }
           72 ( 0.00%)  0           0                     36 ( 0.00%)         0                0                    0                0           0               if (v_w == NULL) {
            .           .           .                      .                  .                .                    .                .           .                   printf("Error: v_w is NULL\n");
            .           .           .                      .                  .                .                    .                .           .                   return;
            .           .           .                      .                  .                .                    .                .           .               }
           36 ( 0.00%)  0           0                     36 ( 0.00%)         0                0                    0                0           0               int filters = kernel->filters;
           72 ( 0.00%)  0           0                     36 ( 0.00%)         0                0                   36 ( 0.00%)       0           0               int channels = kernel->channels;
           72 ( 0.00%)  0           0                     36 ( 0.00%)         0                0                   36 ( 0.00%)       0           0               int size = kernel->size;
        1,692 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)           468 ( 0.00%)         0                0                  108 ( 0.00%)       0           0               for (int f = 0; f < filters; f++) {
        4,212 ( 0.00%)  0           0                  1,872 ( 0.00%)        99 ( 0.00%)      58 ( 0.01%)         468 ( 0.00%)       0           0                   if (v_w[f] == NULL || gradient_weight_avg.kernel_value[f] == NULL) {
            .           .           .                      .                  .                .                    .                .           .                       printf("Error: v_w[%d] or gradient_weight_avg.kernel_value[%d] is NULL\n", f, f);
            .           .           .                      .                  .                .                    .                .           .                       return;
            .           .           .                      .                  .                .                    .                .           .                   }
       13,104 ( 0.00%)  0           0                  4,212 ( 0.00%)         0                0                    0                0           0                   for (int c = 0; c < channels; c++) {
       29,952 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)         7,488 ( 0.00%)       947 ( 0.00%)     451 ( 0.04%)           0                0           0                       if (v_w[f][c] == NULL || gradient_weight_avg.kernel_value[f][c] == NULL) {
            .           .           .                      .                  .                .                    .                .           .                           printf("Error: v_w[%d][%d] or gradient_weight_avg.kernel_value[%d][%d] is NULL\n", f, c, f, c);
            .           .           .                      .                  .                .                    .                .           .                           return;
            .           .           .                      .                  .                .                    .                .           .                       }
       35,136 ( 0.00%)  0           0                  3,744 ( 0.00%)         0                0                    0                0           0                       for (int i = 0; i < size; i++) {
       43,776 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)        10,944 ( 0.00%)     3,739 ( 0.01%)   1,603 ( 0.14%)           0                0           0                           if (v_w[f][c][i] == NULL || gradient_weight_avg.kernel_value[f][c][i] == NULL) {
            .           .           .                      .                  .                .                    .                .           .                               printf("Error: v_w[%d][%d][%d] or gradient_weight_avg.kernel_value[%d][%d][%d] is NULL\n", f, c, i, f, c, i);
            .           .           .                      .                  .                .                    .                .           .                               return;
            .           .           .                      .                  .                .                    .                .           .                           }
       31,968 ( 0.00%)  0           0                      0                  0                0                    0                0           0                           for (int j = 0; j < size; j++) {
       63,936 ( 0.00%)  0           0                 21,312 ( 0.00%)     5,874 ( 0.01%)   2,883 ( 0.26%)      10,656 ( 0.00%)       0           0                               v_w[f][c][i][j] = v_w[f][c][i][j] * momentum + learning_rate * gradient_weight_avg.kernel_value[f][c][i][j];
       59,328 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)        27,072 ( 0.00%)        22 ( 0.00%)       0               10,656 ( 0.00%)       0           0                               kernel->kernel_value[f][c][i][j] -= v_w[f][c][i][j];
            .           .           .                      .                  .                .                    .                .           .                           }
            .           .           .                      .                  .                .                    .                .           .                       }
            .           .           .                      .                  .                .                    .                .           .                   }
            .           .           .                      .                  .                .                    .                .           .               }
          252 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)           252 ( 0.00%)         0                0                    0                0           0           }
            .           .           .                      .                  .                .                    .                .           .           
           12 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0                0                    4 ( 0.00%)       0           0           float* init_v_b(int filter) {
            6 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0                0                    2 ( 0.00%)       0           0               float* v_b = (float*)malloc(filter * sizeof(float));
            6 ( 0.00%)  0           0                      0                  0                0                    0                0           0               if (!v_b) {
            .           .           .                      .                  .                .                    .                .           .                   fprintf(stderr, "malloc v_b failed\n");
            .           .           .                      .                  .                .                    .                .           .                   exit(1);
            .           .           .                      .                  .                .                    .                .           .               }
            4 ( 0.00%)  0           0                      0                  0                0                    0                0           0               for (int i = 0; i < filter; i++) {
           10 ( 0.00%)  0           0                      0                  0                0                    2 ( 0.00%)       0           0                   v_b[i] = 0.0f;
            .           .           .                      .                  .                .                    .                .           .               }
            .           .           .                      .                  .                .                    .                .           .               return v_b;
           10 ( 0.00%)  0           0                      6 ( 0.00%)         0                0                    0                0           0           }
            .           .           .                      .                  .                .                    .                .           .           
           72 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)            36 ( 0.00%)         0                0                    0                0           0           void update_bias_SGD(float** bias, float* gradient_bias_avg, FEATURE_MAP output, float learning_rate, float momentum, float* v_b) {
        1,476 ( 0.00%)  0           0                      0                  0                0                    0                0           0               for (int c = 0; c < output.channels; c++) {
        2,808 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)           936 ( 0.00%)        72 ( 0.00%)      33 ( 0.00%)         468 ( 0.00%)       0           0                   (v_b)[c] = (v_b)[c] * momentum + learning_rate * gradient_bias_avg[c];
        1,548 ( 0.00%)  0           0                    504 ( 0.00%)        90 ( 0.00%)      38 ( 0.00%)         468 ( 0.00%)       0           0                   (*bias)[c] -= (v_b)[c];
            .           .           .                      .                  .                .                    .                .           .               }
           36 ( 0.00%)  0           0                     36 ( 0.00%)         0                0                    0                0           0           }
            .           .           .                      .                  .                .                    .                .           .           
            .           .           .                      .                  .                .                    .                .           .           KERNEL kernel_rotate_180(KERNEL kernel)
          216 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)            18 ( 0.00%)         0                0                  144 ( 0.00%)      36 ( 0.00%)  0           {
           18 ( 0.00%)  0           0                     18 ( 0.00%)         0                0                    0                0           0               int size = kernel.size;
           36 ( 0.00%)  0           0                     18 ( 0.00%)         0                0                   18 ( 0.00%)       0           0               int channels = kernel.channels;
           18 ( 0.00%)  0           0                     18 ( 0.00%)         0                0                    0                0           0               int filters = kernel.filters;
           90 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)             0                  0                0                   18 ( 0.00%)       0           0               KERNEL output = init_kernel(size, channels, filters);
          594 ( 0.00%)  0           0                    180 ( 0.00%)         0                0                    0                0           0               for (int f = 0; f < filters; f++)
            .           .           .                      .                  .                .                    .                .           .               {
        9,540 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)         3,060 ( 0.00%)         0                0                    0                0           0                   for (int c = 0; c < channels; c++)
            .           .           .                      .                  .                .                    .                .           .                   {
       17,280 ( 0.00%)  0           0                      0                  0                0                    0                0           0                       for (int i = 0; i < size; i++)
            .           .           .                      .                  .                .                    .                .           .                       {
       25,920 ( 0.00%)  0           0                  5,760 ( 0.00%)     1,296 ( 0.00%)       0                    0                0           0                           for (int j = 0; j < size; j++)
            .           .           .                      .                  .                .                    .                .           .                           {
       26,190 ( 0.00%)  3 ( 0.02%)  3 ( 0.12%)        14,436 ( 0.00%)     2,070 ( 0.00%)       0                2,916 ( 0.00%)       0           0                               output.kernel_value[f][c][i][j] = kernel.kernel_value[f][c][size - 1 - i][size - 1 - j];
            .           .           .                      .                  .                .                    .                .           .                           }
            .           .           .                      .                  .                .                    .                .           .                       }
            .           .           .                      .                  .                .                    .                .           .                   }
            .           .           .                      .                  .                .                    .                .           .               }
           90 ( 0.00%)  0           0                     54 ( 0.00%)         0                0                   36 ( 0.00%)      18 ( 0.00%)  0               return output;
          216 ( 0.00%) 18 ( 0.12%) 18 ( 0.71%)           180 ( 0.00%)         0                0                    0                0           0           }
            .           .           .                      .                  .                .                    .                .           .           
            .           .           .                      .                  .                .                    .                .           .           KERNEL switch_channels_filters(KERNEL kernel)
          270 ( 0.00%) 18 ( 0.12%) 18 ( 0.71%)            72 ( 0.00%)         0                0                  126 ( 0.00%)       0           0           {
           90 ( 0.00%)  0           0                      0                  0                0                   18 ( 0.00%)       0           0               KERNEL output = init_kernel(kernel.size, kernel.filters, kernel.channels);
          918 ( 0.00%)  0           0                    288 ( 0.00%)         0                0                    0                0           0               for (int c = 0; c < kernel.channels; c++)
            .           .           .                      .                  .                .                    .                .           .               {
        9,792 ( 0.00%)  0           0                      0                  0                0                    0                0           0                   for (int f = 0; f < kernel.filters; f++)
            .           .           .                      .                  .                .                    .                .           .                   {
       14,400 ( 0.00%)  0           0                      0                  0                0                    0                0           0                       for (int i = 0; i < kernel.size; i++)
            .           .           .                      .                  .                .                    .                .           .                       {
        8,640 ( 0.00%)  0           0                      0                  0                0                    0                0           0                           for (int j = 0; j < kernel.size; j++)
            .           .           .                      .                  .                .                    .                .           .                           {
       34,686 ( 0.00%)  4 ( 0.03%)  4 ( 0.16%)        20,196 ( 0.00%)         0                0                2,898 ( 0.00%)       0           0                               output.kernel_value[c][f][i][j] = kernel.kernel_value[f][c][i][j];
            .           .           .                      .                  .                .                    .                .           .                           }
            .           .           .                      .                  .                .                    .                .           .                       }
            .           .           .                      .                  .                .                    .                .           .                   }
            .           .           .                      .                  .                .                    .                .           .               }
           72 ( 0.00%)  0           0                     36 ( 0.00%)         0                0                   36 ( 0.00%)       0           0               return output;
          216 ( 0.00%)  0           0                    162 ( 0.00%)         0                0                    0                0           0           }
            .           .           .                      .                  .                .                    .                .           .           
            .           .           .                      .                  .                .                    .                .           .           FEATURE_MAP update_input(FEATURE_MAP matrix_gradient, KERNEL kernel, int stride)
          216 ( 0.00%)  5 ( 0.03%)  5 ( 0.20%)            18 ( 0.00%)        18 ( 0.00%)       0                  108 ( 0.00%)       0           0           {
          126 ( 0.00%)  0           0                     54 ( 0.00%)         0                0                   72 ( 0.00%)      18 ( 0.00%)  0               KERNEL rota_kernel = kernel_rotate_180(kernel);
          126 ( 0.00%)  3 ( 0.02%)  3 ( 0.12%)            54 ( 0.00%)         0                0                   72 ( 0.00%)       0           0               KERNEL final_kernel = switch_channels_filters(rota_kernel);
           54 ( 0.00%)  0           0                      0                  0                0                   18 ( 0.00%)       0           0               free_kernel(&rota_kernel);
           36 ( 0.00%)  0           0                     18 ( 0.00%)         0                0                    0                0           0               int padding = final_kernel.size - 1;
           72 ( 0.00%)  0           0                     18 ( 0.00%)         0                0                   18 ( 0.00%)       0           0               float *bias = (float *)calloc(final_kernel.filters, sizeof(float));
            .           .           .                      .                  .                .                    .                .           .           
          198 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)           108 ( 0.00%)         0                0                  126 ( 0.00%)       0           0               FEATURE_MAP output = Conv2D(matrix_gradient, final_kernel, padding, stride, bias); // với stride = 1
           54 ( 0.00%)  0           0                      0                  0                0                   18 ( 0.00%)      18 ( 0.00%)  0               free_kernel(&final_kernel);
           36 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)             0                  0                0                   18 ( 0.00%)       0           0               free(bias);
           72 ( 0.00%)  0           0                     36 ( 0.00%)         0                0                   36 ( 0.00%)      36 ( 0.00%)  6 ( 0.00%)      return output;
          198 ( 0.00%)  0           0                    144 ( 0.00%)         0                0                    0                0           0           }
            .           .           .                      .                  .                .                    .                .           .           
            .           .           .                      .                  .                .                    .                .           .           FEATURE_MAP backprop_max_pooling(FEATURE_MAP input, FEATURE_MAP gradient_matrix, int kernel_size, int stride, int*** index_row, int*** index_col)
          306 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)            18 ( 0.00%)         0                0                  198 ( 0.00%)       0           0           {
           36 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)            18 ( 0.00%)         0                0                   18 ( 0.00%)       0           0               int out_height = input.height;
           36 ( 0.00%)  0           0                     18 ( 0.00%)         0                0                   18 ( 0.00%)       0           0               int out_width = input.width;
           36 ( 0.00%)  0           0                     18 ( 0.00%)         0                0                   18 ( 0.00%)       0           0               int out_channels = input.channels;
           18 ( 0.00%)  0           0                     18 ( 0.00%)         0                0                    0                0           0               int out_batch_size = input.batch_size;
            .           .           .                      .                  .                .                    .                .           .               int slide_count;
            .           .           .                      .                  .                .                    .                .           .               int slide_row_count;
            .           .           .                      .                  .                .                    .                .           .               int slide_col_count;
           90 ( 0.00%)  0           0                      0                  0                0                   18 ( 0.00%)       0           0               FEATURE_MAP output = init_feature_map(out_height, out_width, out_channels, out_batch_size);
        1,782 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)           576 ( 0.00%)         0                0                    0                0           0               for (int b = 0; b < out_batch_size; b++)
            .           .           .                      .                  .                .                    .                .           .               {
       48,960 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)        37,440 ( 0.00%)        18 ( 0.00%)       0                1,152 ( 0.00%)       0           0                   for (int c = 0; c < out_channels; c++)
            .           .           .                      .                  .                .                    .                .           .                   {
        9,216 ( 0.00%)  0           0                      0                  0                0                9,216 ( 0.00%)       0           0                       slide_count = 0;
            .           .           .                      .                  .                .                    .                .           .                       slide_row_count = 0;
    1,253,376 ( 0.01%)  3 ( 0.02%)  3 ( 0.12%)     1,041,408 ( 0.03%)         0                0               36,864 ( 0.01%)       0           0                       for (int i = 0; i < out_height; i += stride)
            .           .           .                      .                  .                .                    .                .           .                       {
            .           .           .                      .                  .                .                    .                .           .                           slide_col_count = 0;
    7,815,168 ( 0.06%)  0           0              4,866,048 ( 0.12%)         0                0              147,456 ( 0.02%)       0           0                           for (int j = 0; j < out_width; j += stride)
            .           .           .                      .                  .                .                    .                .           .                           {
   10,469,376 ( 0.08%)  3 ( 0.02%)  3 ( 0.12%)     4,866,048 ( 0.12%)         0                0              147,456 ( 0.02%)       0           0                               if (slide_count >= 16 * 16) {
            .           .           .                      .                  .                .                    .                .           .                                   printf("slide_count overflow! b=%d c=%d\n", b, c);
            .           .           .                      .                  .                .                    .                .           .                                   exit(1);
            .           .           .                      .                  .                .                    .                .           .                               }
   25,952,256 ( 0.20%)  1 ( 0.01%)  1 ( 0.04%)     7,077,888 ( 0.17%)         0                0                    0                0           0                               for (int m = 0; m < kernel_size; m++)
            .           .           .                      .                  .                .                    .                .           .                               {
   38,184,238 ( 0.30%)  2 ( 0.01%)  2 ( 0.08%)             0                  0                0                    0                0           0                                   for (int n = 0; n < kernel_size; n++)
            .           .           .                      .                  .                .                    .                .           .                                   {
   58,982,400 ( 0.46%)  0           0             30,670,848 ( 0.74%)   302,733 ( 0.47%) 105,974 ( 9.49%)           0                0           0                                       if ((i + m == index_row[b][c][slide_count]) && (j + n == index_col[b][c][slide_count]))
            .           .           .                      .                  .                .                    .                .           .                                       {
   23,593,176 ( 0.18%)  0           0             18,874,404 ( 0.46%)   249,538 ( 0.38%)       0            2,359,350 ( 0.38%) 465,193 ( 4.41%)  7 ( 0.00%)                                  output.fm_value[b][c][i + m][j + n] = gradient_matrix.fm_value[b][c][slide_row_count][slide_col_count];
            .           .           .                      .                  .                .                    .                .           .                                           // printf("slide_col slide_row: %d %d\n", slide_col_count, slide_row_count);
            .           .           .                      .                  .                .                    .                .           .                                       }
            .           .           .                      .                  .                .                    .                .           .                                   }
            .           .           .                      .                  .                .                    .                .           .                               }
    2,359,296 ( 0.02%)  0           0              2,359,296 ( 0.06%)         0                0                    0                0           0                               slide_count++;
            .           .           .                      .                  .                .                    .                .           .                               slide_col_count++;
            .           .           .                      .                  .                .                    .                .           .                           }
            .           .           .                      .                  .                .                    .                .           .                           slide_row_count++;
            .           .           .                      .                  .                .                    .                .           .                       }
            .           .           .                      .                  .                .                    .                .           .                   }
            .           .           .                      .                  .                .                    .                .           .               }
           90 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)            54 ( 0.00%)         0                0                   36 ( 0.00%)      18 ( 0.00%)  1 ( 0.00%)      return output;
          216 ( 0.00%)  0           0                    180 ( 0.00%)        36 ( 0.00%)       1 ( 0.00%)           0                0           0           }
            .           .           .                      .                  .                .                    .                .           .           
            .           .           .                      .                  .                .                    .                .           .           /*FEATURE_MAP backprop_global_max_pooling(FEATURE_MAP input, float* matrix_gradient, int* index_row, int* index_col) {
            .           .           .                      .                  .                .                    .                .           .               int out_height = input.height;
            .           .           .                      .                  .                .                    .                .           .               int out_width = input.width;
            .           .           .                      .                  .                .                    .                .           .               int out_channels = input.channels;
            .           .           .                      .                  .                .                    .                .           .               FEATURE_MAP output = init_feature_map(out_height, out_width, out_channels);
            .           .           .                      .                  .                .                    .                .           .               for (int c = 0; c < out_channels; c++) {
            .           .           .                      .                  .                .                    .                .           .                   for (int i = 0; i < out_height; i++) {
-- line 369 ----------------------------------------
-- line 373 ----------------------------------------
            .           .           .                      .                  .                .                    .                .           .                       }
            .           .           .                      .                  .                .                    .                .           .                   }
            .           .           .                      .                  .                .                    .                .           .               }
            .           .           .                      .                  .                .                    .                .           .               return output;
            .           .           .                      .                  .                .                    .                .           .           }
            .           .           .                      .                  .                .                    .                .           .           */
            .           .           .                      .                  .                .                    .                .           .           
            .           .           .                      .                  .                .                    .                .           .           float **backprop_loss_softmax(int* y, float* y_predict, int number_of_category, int batch_size)
          234 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)             0                  0                0                  126 ( 0.00%)       0           0           {
           54 ( 0.00%)  0           0                      0                  0                0                   18 ( 0.00%)       0           0               float **grad = (float **)malloc(number_of_category * sizeof(float *));
          612 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)           180 ( 0.00%)         0                0                    0                0           0               for (int i = 0; i < number_of_category; i++)
            .           .           .                      .                  .                .                    .                .           .               {
          792 ( 0.00%)  0           0                     18 ( 0.00%)         0                0                  378 ( 0.00%)       0           0                   grad[i] = (float *)calloc(batch_size, sizeof(float));
            .           .           .                      .                  .                .                    .                .           .               }
        2,484 ( 0.00%)  3 ( 0.02%)  3 ( 0.12%)            18 ( 0.00%)         0                0                    0                0           0               for (int b = 0; b < batch_size; b++)
            .           .           .                      .                  .                .                    .                .           .               {
       18,432 ( 0.00%)  0           0                      0                  0                0                    0                0           0                   for (int i = 0; i < number_of_category; i++)
            .           .           .                      .                  .                .                    .                .           .                   {
       45,504 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)        17,856 ( 0.00%)       378 ( 0.00%)     356 ( 0.03%)       5,760 ( 0.00%)       0           0                       grad[i][b] = (y_predict[b * number_of_category + i] - (float)y[b * number_of_category + i]) / batch_size;
            .           .           .                      .                  .                .                    .                .           .                   }
            .           .           .                      .                  .                .                    .                .           .               }
            .           .           .                      .                  .                .                    .                .           .               return grad;
          162 ( 0.00%)  0           0                    126 ( 0.00%)         0                0                    0                0           0           }
            .           .           .                      .                  .                .                    .                .           .           
           90 ( 0.00%)  0           0                      0                  0                0                   54 ( 0.00%)       0           0           void free_backprop_loss_softmax(float **loss_softmax, int number_of_category){
          648 ( 0.00%)  0           0                      0                  0                0                    0                0           0               for (int i =0; i< number_of_category; i++){
          360 ( 0.00%)  0           0                    180 ( 0.00%)        16 ( 0.00%)       7 ( 0.00%)         180 ( 0.00%)       0           0                   free(loss_softmax[i]);
            .           .           .                      .                  .                .                    .                .           .               }
           36 ( 0.00%)  0           0                      0                  0                0                    0                0           0               free(loss_softmax);
           54 ( 0.00%)  0           0                     54 ( 0.00%)         0                0                    0                0           0           }
            .           .           .                      .                  .                .                    .                .           .           
            .           .           .                      .                  .                .                    .                .           .           
          324 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)             0                  0                0                  180 ( 0.00%)       0           0           void kernel_gradient_average(KERNEL* kernel_gradient, int batch_size) {
        1,512 ( 0.00%)  0           0                     36 ( 0.00%)        36 ( 0.00%)       0                    0                0           0               for (int f = 0; f < kernel_gradient->filters; f++) {
       12,312 ( 0.00%)  0           0                     36 ( 0.00%)         0                0                    0                0           0                   for (int c = 0; c < kernel_gradient->channels; c++) {
       27,180 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)           468 ( 0.00%)         0                0                    0                0           0                       for (int i = 0; i < kernel_gradient->size; i++) {
       31,968 ( 0.00%)  0           0                      0                  0                0                    0                0           0                           for (int j = 0; j < kernel_gradient->size; j++) {
       74,592 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)        27,360 ( 0.00%)     5,346 ( 0.01%)   1,927 ( 0.17%)      10,656 ( 0.00%)       0           0                               kernel_gradient->kernel_value[f][c][i][j] = kernel_gradient->kernel_value[f][c][i][j] / batch_size;
            .           .           .                      .                  .                .                    .                .           .                           }
            .           .           .                      .                  .                .                    .                .           .                       }
            .           .           .                      .                  .                .                    .                .           .                   }
            .           .           .                      .                  .                .                    .                .           .               }
          216 ( 0.00%)  0           0                    216 ( 0.00%)         0                0                    0                0           0           }
            .           .           .                      .                  .                .                    .                .           .           
           36 ( 0.00%)  0           0                      0                  0                0                    0                0           0           void bias_gradient_average(float** bias_gradient, int channels, int batch_size) {
        1,476 ( 0.00%)  0           0                      0                  0                0                    0                0           0               for (int c = 0; c < channels; c++) {
        2,088 ( 0.00%)  0           0                    504 ( 0.00%)        27 ( 0.00%)       0                  468 ( 0.00%)       0           0                   (*bias_gradient)[c] = (*bias_gradient)[c] / batch_size;
            .           .           .                      .                  .                .                    .                .           .               }
           36 ( 0.00%)  0           0                     36 ( 0.00%)         0                0                    0                0           0           }
--------------------------------------------------------------------------------
-- Auto-annotated source: /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/convolution.c
--------------------------------------------------------------------------------
Ir                     I1mr        ILmr        Dr                     D1mr               DLmr           Dw                  D1mw               DLmw             

            .           .           .                      .                  .              .                   .                  .                .           ﻿#include "main.h"
            .           .           .                      .                  .              .                   .                  .                .           float *initialize_bias_conv2d(int channels)
           24 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0              0                  12 ( 0.00%)         0                0           {
           12 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0              0                   4 ( 0.00%)         0                0               float *bias = (float *)malloc(channels * sizeof(float));
          180 ( 0.00%)  0           0                      0                  0              0                   0                  0                0               for (int i = 0; i < channels; i++)
            .           .           .                      .                  .              .                   .                  .                .               {
          416 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)           104 ( 0.00%)         1 ( 0.00%)     0                 104 ( 0.00%)         1 ( 0.00%)       1 ( 0.00%)          bias[i] = ((float)rand() / RAND_MAX) * 0.01;
            .           .           .                      .                  .              .                   .                  .                .               }
            .           .           .                      .                  .              .                   .                  .                .               return bias;
           20 ( 0.00%)  0           0                     16 ( 0.00%)         0              0                   0                  0                0           }
            .           .           .                      .                  .              .                   .                  .                .           
            .           .           .                      .                  .              .                   .                  .                .           FEATURE_MAP Conv2D(FEATURE_MAP input, KERNEL kernel, int padding, int stride, float *bias)
       16,226 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)         3,416 ( 0.00%)         0              0              11,102 ( 0.00%)       397 ( 0.00%)       0           {
        6,306 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)         2,090 ( 0.00%)         0              0               2,508 ( 0.00%)       463 ( 0.00%)       0               input = (padding > 0) ? padding_feature_map(input, padding) : input;
        5,560 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)         1,290 ( 0.00%)         0              0                 854 ( 0.00%)        28 ( 0.00%)       0               int out_height = (input.height - kernel.size) / stride + 1;
        5,124 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)           854 ( 0.00%)         0              0                 854 ( 0.00%)         0                0               int out_width = (input.width - kernel.size) / stride + 1;
            .           .           .                      .                  .              .                   .                  .                .           
        6,396 ( 0.00%)  0           0                  2,144 ( 0.00%)         0              0               1,708 ( 0.00%)       872 ( 0.01%)       0               FEATURE_MAP output = init_feature_map(out_height, out_width, kernel.filters, input.batch_size);
        9,292 ( 0.00%)  0           0                  2,528 ( 0.00%)         0              0                   0                  0                0               for (int b = 0; b < output.batch_size; b++)
            .           .           .                      .                  .              .                   .                  .                .               {
      116,416 ( 0.00%)  0           0                 37,120 ( 0.00%)         0              0               2,528 ( 0.00%)         0                0                   for (int f = 0; f < kernel.filters; f++)
            .           .           .                      .                  .              .                   .                  .                .                   {
    5,062,112 ( 0.04%)  2 ( 0.01%)  2 ( 0.08%)     4,051,232 ( 0.10%)         0              0             103,776 ( 0.02%)         0                0                       for (int i = 0; i < out_height; i++)
            .           .           .                      .                  .              .                   .                  .                .                       {
  127,501,824 ( 0.99%)  0           0             63,349,248 ( 1.53%)         0              0          20,848,640 ( 3.39%)         0                0                           for (int j = 0; j < out_width; j++)
            .           .           .                      .                  .              .                   .                  .                .                           {
   62,545,920 ( 0.49%)  0           0                      0                  0              0                   0                  0                0                               float sum = 0.0f;
  438,870,016 ( 3.41%)  1 ( 0.01%)  1 ( 0.04%)   153,239,552 ( 3.70%)         0              0                   0                  0                0                               for (int c = 0; c < kernel.channels; c++)
            .           .           .                      .                  .              .                   .                  .                .                               {
  845,545,472 ( 6.56%)  0           0                      0                  0              0                   0                  0                0                                   for (int m = 0; m < kernel.size; m++)
            .           .           .                      .                  .              .                   .                  .                .                                   {
1,693,450,240 (13.14%)  0           0            207,486,976 ( 5.01%)    56,093 ( 0.09%)     0                   0                  0                0                                       for (int n = 0; n < kernel.size; n++)
            .           .           .                      .                  .              .                   .                  .                .                                       {
3,096,708,780 (24.03%)  1 ( 0.01%)  1 ( 0.04%) 1,644,299,948 (39.73%) 1,012,324 ( 1.56%) 4,377 ( 0.39%)          0                  0                0                                           sum += (input.fm_value[b][c][i * stride + m][j * stride + n] * kernel.kernel_value[f][c][m][n]);
            .           .           .                      .                  .              .                   .                  .                .                                       }
            .           .           .                      .                  .              .                   .                  .                .                                   }
            .           .           .                      .                  .              .                   .                  .                .                               }
   93,855,758 ( 0.73%)  4 ( 0.03%)  4 ( 0.16%)    68,975,960 ( 1.67%)    99,538 ( 0.15%)    25 ( 0.00%) 23,262,040 ( 3.78%) 1,480,367 (14.02%)       0                               output.fm_value[b][f][i][j] = sum + bias[f];
            .           .           .                      .                  .              .                   .                  .                .                           }
            .           .           .                      .                  .              .                   .                  .                .                       }
            .           .           .                      .                  .              .                   .                  .                .                   }
            .           .           .                      .                  .              .                   .                  .                .               }
        2,562 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)           854 ( 0.00%)         0              0                   0                  0                0               if (padding > 0)
            .           .           .                      .                  .              .                   .                  .                .               {
        1,254 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0              0                 418 ( 0.00%)       418 ( 0.00%)       0                   free_feature_map(&input);
            .           .           .                      .                  .              .                   .                  .                .               }
        4,270 ( 0.00%)  0           0                  2,562 ( 0.00%)       764 ( 0.00%)     0               1,708 ( 0.00%)     1,672 ( 0.02%)       0               return output;
       10,248 ( 0.00%)  0           0                  8,540 ( 0.00%)     1,220 ( 0.00%)     0                   0                  0                0           }
            .           .           .                      .                  .              .                   .                  .                .           
            .           .           .                      .                  .              .                   .                  .                .           FEATURE_MAP max_pooling(FEATURE_MAP input, int kernel_size, int stride, int ****index_row, int ****index_col)
        8,778 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)         1,672 ( 0.00%)         0              0               4,598 ( 0.00%)        18 ( 0.00%)       0           {
        3,344 ( 0.00%)  0           0                    418 ( 0.00%)         0              0                 418 ( 0.00%)         0                0               int out_height = (input.height - kernel_size) / stride + 1;
        2,508 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)           418 ( 0.00%)         0              0                 418 ( 0.00%)         0                0               int out_width = (input.width - kernel_size) / stride + 1;
        2,090 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0              0                 836 ( 0.00%)         0                0               FEATURE_MAP output = init_feature_map(out_height, out_width, input.channels, input.batch_size);
            .           .           .                      .                  .              .                   .                  .                .           
        1,254 ( 0.00%)  0           0                    418 ( 0.00%)        18 ( 0.00%)     0                   0                  0                0               int max_slide_count = out_height * out_width;
          836 ( 0.00%)  0           0                      0                  0              0                   0                  0                0               if (max_slide_count > 16 * 16) {
            .           .           .                      .                  .              .                   .                  .                .                   fprintf(stderr, "Error: Output size (%d) exceeds allocated index size (%d)\n", 
            .           .           .                      .                  .              .                   .                  .                .                           max_slide_count, 16 * 16);
            .           .           .                      .                  .              .                   .                  .                .                   exit(1);
            .           .           .                      .                  .              .                   .                  .                .               } 
            .           .           .                      .                  .              .                   .                  .                .           
        2,508 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)           836 ( 0.00%)       413 ( 0.00%)     0                 836 ( 0.00%)       414 ( 0.00%)       0               *index_row = initial_index_max_pooling(input.batch_size, input.channels, max_slide_count);
        2,926 ( 0.00%)  0           0                    418 ( 0.00%)         0              0               1,254 ( 0.00%)       430 ( 0.00%)       0               *index_col = initial_index_max_pooling(input.batch_size, input.channels, max_slide_count);
            .           .           .                      .                  .              .                   .                  .                .           
            .           .           .                      .                  .              .                   .                  .                .               //printf("batch_size: %d\n", input.batch_size);
            .           .           .                      .                  .              .                   .                  .                .           
        4,740 ( 0.00%)  3 ( 0.02%)  3 ( 0.12%)         2,928 ( 0.00%)         0              0                   0                  0                0               for (int b = 0; b < input.batch_size; b++)
            .           .           .                      .                  .              .                   .                  .                .               {
       68,320 ( 0.00%)  0           0                 47,824 ( 0.00%)         0              0                 976 ( 0.00%)         0                0                   for (int c = 0; c < input.channels; c++)
            .           .           .                      .                  .              .                   .                  .                .                   {
       15,616 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0              0              15,616 ( 0.00%)         0                0                       int slide_count = 0;
    1,327,360 ( 0.01%)  2 ( 0.01%)  2 ( 0.08%)       765,184 ( 0.02%)         0              0              15,616 ( 0.00%)         0                0                       for (int i = 0; i < out_height; i++)
            .           .           .                      .                  .              .                   .                  .                .                       {
   32,731,136 ( 0.25%)  0           0              8,245,248 ( 0.20%)         0              0                   0                  0                0                           for (int j = 0; j < out_width; j++)
            .           .           .                      .                  .              .                   .                  .                .                           {
    6,246,400 ( 0.05%) 18 ( 0.12%) 18 ( 0.71%)     5,496,832 ( 0.13%)   508,084 ( 0.78%)     0             249,856 ( 0.04%)         0                0                               float max = input.fm_value[b][c][i * stride][j * stride];
    6,246,400 ( 0.05%)  0           0              1,748,992 ( 0.04%)     3,691 ( 0.01%)     0           3,997,696 ( 0.65%)   254,732 ( 2.41%) 104,732 ( 5.95%)                      (*index_row)[b][c][slide_count] = i * stride;
    4,497,408 ( 0.03%)  0           0                499,712 ( 0.01%)        86 ( 0.00%)     0           3,997,696 ( 0.65%)   248,652 ( 2.36%)  83,801 ( 4.76%)                      (*index_col)[b][c][slide_count] = j * stride;
            .           .           .                      .                  .              .                   .                  .                .           
   59,965,440 ( 0.47%)  0           0              3,997,696 ( 0.10%)         0              0                   0                  0                0                               for (int m = 0; m < kernel_size; m++)
            .           .           .                      .                  .              .                   .                  .                .                               {
   71,958,528 ( 0.56%)  1 ( 0.01%)  1 ( 0.04%)             0                  0              0                   0                  0                0                                   for (int n = 0; n < kernel_size; n++)
            .           .           .                      .                  .              .                   .                  .                .                                   {
   15,990,784 ( 0.12%)  0           0                      0                  0              0                   0                  0                0                                       int row = i * stride + m;
            .           .           .                      .                  .              .                   .                  .                .                                       int col = j * stride + n;
   51,970,048 ( 0.40%)  2 ( 0.01%)  2 ( 0.08%)    15,990,784 ( 0.39%)   686,214 ( 1.05%)     0                   0                  0                0                                       if (input.fm_value[b][c][row][col] > max)
            .           .           .                      .                  .              .                   .                  .                .                                       {
      962,483 ( 0.01%)  0           0                      0                  0              0                   0                  0                0                                           max = input.fm_value[b][c][row][col];
      962,483 ( 0.01%)  0           0                      0                  0              0             962,483 ( 0.16%)         0                0                                           (*index_row)[b][c][slide_count] = row;
      962,483 ( 0.01%)  0           0                      0                  0              0             962,483 ( 0.16%)         0                0                                           (*index_col)[b][c][slide_count] = col;
            .           .           .                      .                  .              .                   .                  .                .                                       }
            .           .           .                      .                  .              .                   .                  .                .                                   }
            .           .           .                      .                  .              .                   .                  .                .                               }
            .           .           .                      .                  .              .                   .                  .                .           
    7,002,238 ( 0.05%) 20 ( 0.14%) 20 ( 0.79%)     1,250,116 ( 0.03%)    34,274 ( 0.05%)     0           4,250,478 ( 0.69%)   317,710 ( 3.01%)       0                               output.fm_value[b][c][i][j] = max;
      999,424 ( 0.01%)  0           0                499,712 ( 0.01%)         0              0             249,856 ( 0.04%)         0                0                               slide_count++;
            .           .           .                      .                  .              .                   .                  .                .                           }
            .           .           .                      .                  .              .                   .                  .                .                       }
            .           .           .                      .                  .              .                   .                  .                .                   }
            .           .           .                      .                  .              .                   .                  .                .               }
        2,090 ( 0.00%)  0           0                  1,254 ( 0.00%)       418 ( 0.00%)     0                 836 ( 0.00%)       436 ( 0.00%)      12 ( 0.00%)      return output;
        5,016 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)         4,180 ( 0.00%)       836 ( 0.00%)     0                   0                  0                0           }
            .           .           .                      .                  .              .                   .                  .                .           
            .           .           .                      .                  .              .                   .                  .                .           /*FEATURE_MAP avg_pooling(FEATURE_MAP input, int kernel_size, int stride) {
            .           .           .                      .                  .              .                   .                  .                .               int out_height = (input.height - kernel_size) / stride + 1;
            .           .           .                      .                  .              .                   .                  .                .               int out_width = (input.width - kernel_size) / stride + 1;
            .           .           .                      .                  .              .                   .                  .                .               FEATURE_MAP output = init_feature_map(out_height, out_width, input.channels);
            .           .           .                      .                  .              .                   .                  .                .               float max = input.fm_value[0][0][0];
            .           .           .                      .                  .              .                   .                  .                .               for (int c = 0; c < input.channels; c++) {
            .           .           .                      .                  .              .                   .                  .                .                   for (int i = 0; i < out_height; i++) {
-- line 111 ----------------------------------------
-- line 144 ----------------------------------------
            .           .           .                      .                  .              .                   .                  .                .                   result[c] = max;
            .           .           .                      .                  .              .                   .                  .                .               }
            .           .           .                      .                  .              .                   .                  .                .               return result;
            .           .           .                      .                  .              .                   .                  .                .           }
            .           .           .                      .                  .              .                   .                  .                .           */
            .           .           .                      .                  .              .                   .                  .                .           
            .           .           .                      .                  .              .                   .                  .                .           
            .           .           .                      .                  .              .                   .                  .                .           float **Flatten(FEATURE_MAP input, int flat_dim)
        5,852 ( 0.00%)  0           0                  1,672 ( 0.00%)         0              0               2,508 ( 0.00%)         0                0           {
        1,254 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0              0                 418 ( 0.00%)         0                0               float **output = (float **)malloc(flat_dim * sizeof(float *));
    3,212,748 ( 0.02%)  1 ( 0.01%)  1 ( 0.04%)           836 ( 0.00%)       418 ( 0.00%)     0                   0                  0                0               for (int i = 0; i < flat_dim; i++)
            .           .           .                      .                  .              .                   .                  .                .               {
    3,214,420 ( 0.02%)  0           0                      0                  0              0           2,140,996 ( 0.35%)   133,614 ( 1.27%)   3,151 ( 0.18%)          output[i] = (float *)malloc(input.batch_size * sizeof(float));
            .           .           .                      .                  .              .                   .                  .                .               }
        4,182 ( 0.00%)  0           0                    976 ( 0.00%)       976 ( 0.00%)     0                   0                  0                0               for (int b = 0; b < input.batch_size; b++)
            .           .           .                      .                  .              .                   .                  .                .               {
          976 ( 0.00%)  0           0                      0                  0              0                   0                  0                0                   size_t k = 0;
       33,184 ( 0.00%)  0           0                      0                  0              0                   0                  0                0                   for (int c = 0; c < input.channels; c++)
            .           .           .                      .                  .              .                   .                  .                .                   {
      497,760 ( 0.00%)  0           0                      0                  0              0                   0                  0                0                       for (int h = 0; h < input.height; h++)
            .           .           .                      .                  .              .                   .                  .                .                       {
    5,309,440 ( 0.04%)  0           0                      0                  0              0                   0                  0                0                           for (int w = 0; w < input.width; w++)
            .           .           .                      .                  .              .                   .                  .                .                           {
    8,748,304 ( 0.07%)  2 ( 0.01%)  2 ( 0.08%)     5,466,018 ( 0.13%)   538,292 ( 0.83%)     0           2,498,978 ( 0.41%) 1,993,238 (18.88%)  19,316 ( 1.10%)                      output[k][b] = input.fm_value[b][c][h][w];
    2,498,560 ( 0.02%)  0           0                      0                  0              0                   0                  0                0                               k++;
            .           .           .                      .                  .              .                   .                  .                .                           }
            .           .           .                      .                  .              .                   .                  .                .                       }
            .           .           .                      .                  .              .                   .                  .                .                   }
            .           .           .                      .                  .              .                   .                  .                .               }
            .           .           .                      .                  .              .                   .                  .                .               return output;
        3,762 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)         2,926 ( 0.00%)       418 ( 0.00%)     0                   0                  0                0           }
            .           .           .                      .                  .              .                   .                  .                .           void free_Flatten(float **input, int flat_dim)
        2,090 ( 0.00%)  0           0                      0                  0              0               1,254 ( 0.00%)         0                0           {
    3,212,748 ( 0.02%)  0           0                      0                  0              0                   0                  0                0               for (int i = 0; i < flat_dim; i++)
            .           .           .                      .                  .              .                   .                  .                .               {
    2,140,160 ( 0.02%)  0           0              1,070,080 ( 0.03%)   134,038 ( 0.21%)   843 ( 0.08%)  1,070,080 ( 0.17%)         0                0                   free(input[i]);
            .           .           .                      .                  .              .                   .                  .                .               }
          836 ( 0.00%)  0           0                      0                  0              0                   0                  0                0               free(input);
        1,254 ( 0.00%)  0           0                  1,254 ( 0.00%)         0              0                   0                  0                0           }
            .           .           .                      .                  .              .                   .                  .                .           
            .           .           .                      .                  .              .                   .                  .                .           /*int argmax(float* arr, int length) {
            .           .           .                      .                  .              .                   .                  .                .               int idx = 0;
            .           .           .                      .                  .              .                   .                  .                .               float max = arr[0];
            .           .           .                      .                  .              .                   .                  .                .               for (int i = 1; i < length; i++) {
            .           .           .                      .                  .              .                   .                  .                .                   if (arr[i] > max) {
            .           .           .                      .                  .              .                   .                  .                .                       max = arr[i];
            .           .           .                      .                  .              .                   .                  .                .                       idx = i;
            .           .           .                      .                  .              .                   .                  .                .                   }
            .           .           .                      .                  .              .                   .                  .                .               }
            .           .           .                      .                  .              .                   .                  .                .               return idx;
            .           .           .                      .                  .              .                   .                  .                .           }
            .           .           .                      .                  .              .                   .                  .                .           */
            .           .           .                      .                  .              .                   .                  .                .           int*** initial_index_max_pooling(int batch_size, int channels, int size_output_square)
       10,032 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0              0               5,852 ( 0.00%)         0                0           {
        3,344 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0              0               2,508 ( 0.00%)         0                0               int*** index = (int***)malloc(batch_size * sizeof(int**));
        1,672 ( 0.00%)  0           0                      0                  0              0                   0                  0                0               if (!index) {
            .           .           .                      .                  .              .                   .                  .                .                   printf("malloc index failed\n");
            .           .           .                      .                  .              .                   .                  .                .                   exit(1);
            .           .           .                      .                  .              .                   .                  .                .               }
            .           .           .                      .                  .              .                   .                  .                .           
        7,528 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)         1,952 ( 0.00%)       396 ( 0.00%)     0                   0                  0                0               for (int b = 0; b < batch_size; b++)
            .           .           .                      .                  .              .                   .                  .                .               {
       15,056 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)         4,740 ( 0.00%)         0              0               6,692 ( 0.00%)       109 ( 0.00%)      35 ( 0.00%)          index[b] = (int**)malloc(channels * sizeof(int*));
        3,904 ( 0.00%)  0           0                      0                  0              0                   0                  0                0                   if (!index[b]) {
            .           .           .                      .                  .              .                   .                  .                .                       printf("malloc index[%d] failed\n", b);
            .           .           .                      .                  .              .                   .                  .                .                       exit(1);
            .           .           .                      .                  .              .                   .                  .                .                   }
            .           .           .                      .                  .              .                   .                  .                .           
      103,456 ( 0.00%)  0           0                  1,952 ( 0.00%)         0              0                   0                  0                0                   for (int c = 0; c < channels; c++)
            .           .           .                      .                  .              .                   .                  .                .                   {
       95,368 ( 0.00%)  0           0                      0                  0              0              62,464 ( 0.01%)     2,087 ( 0.02%)     531 ( 0.03%)              index[b][c] = (int*)malloc(size_output_square * sizeof(int));
       62,464 ( 0.00%)  0           0                      0                  0              0                   0                  0                0                       if (!index[b][c]) {
            .           .           .                      .                  .              .                   .                  .                .                           printf("malloc index[%d][%d] failed\n", b, c);
            .           .           .                      .                  .              .                   .                  .                .                           exit(1);
            .           .           .                      .                  .              .                   .                  .                .                       }
            .           .           .                      .                  .              .                   .                  .                .                   }
            .           .           .                      .                  .              .                   .                  .                .           
            .           .           .                      .                  .              .                   .                  .                .               }
            .           .           .                      .                  .              .                   .                  .                .           
            .           .           .                      .                  .              .                   .                  .                .               return index;
        7,524 ( 0.00%)  0           0                  6,688 ( 0.00%)       429 ( 0.00%)     0                   0                  0                0           }
            .           .           .                      .                  .              .                   .                  .                .           
            .           .           .                      .                  .              .                   .                  .                .           
            .           .           .                      .                  .              .                   .                  .                .           /*int* initial_index_global_max_pooling(int channels) {
            .           .           .                      .                  .              .                   .                  .                .               int* index = (int*)malloc(channels * sizeof(int));
            .           .           .                      .                  .              .                   .                  .                .               return index;
            .           .           .                      .                  .              .                   .                  .                .           }
            .           .           .                      .                  .              .                   .                  .                .           */
            .           .           .                      .                  .              .                   .                  .                .           void free_index_max_pooling(int*** index, int batch_size, int channels)
        7,524 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0              0               5,016 ( 0.00%)         0                0           {
        1,672 ( 0.00%)  0           0                      0                  0              0                   0                  0                0               if (!index) return;
       13,380 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)             0                  0              0                   0                  0                0               for (int b = 0; b < batch_size; b++)
            .           .           .                      .                  .              .                   .                  .                .               {
        5,856 ( 0.00%)  0           0                  1,952 ( 0.00%)       798 ( 0.00%)    32 ( 0.00%)          0                  0                0                   if (!index[b]) continue;
       99,552 ( 0.00%)  0           0                      0                  0              0                   0                  0                0                   for (int c = 0; c < channels; c++)
            .           .           .                      .                  .              .                   .                  .                .                   {
       62,464 ( 0.00%)  0           0                 31,232 ( 0.00%)     3,632 ( 0.01%)   547 ( 0.05%)     31,232 ( 0.01%)         0                0                       free(index[b][c]);
       62,464 ( 0.00%)  0           0                 31,232 ( 0.00%)         0              0              31,232 ( 0.01%)         0                0                       index[b][c] = NULL;
            .           .           .                      .                  .              .                   .                  .                .                   }
        1,952 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)             0                  0              0               1,952 ( 0.00%)         0                0                   free(index[b]);
        1,952 ( 0.00%)  0           0                      0                  0              0               1,952 ( 0.00%)         2 ( 0.00%)       0                   index[b] = NULL;
            .           .           .                      .                  .              .                   .                  .                .               }
        1,672 ( 0.00%)  0           0                      0                  0              0                   0                  0                0               free(index);
        5,852 ( 0.00%)  0           0                  5,016 ( 0.00%)        19 ( 0.00%)     0                   0                  0                0           }
            .           .           .                      .                  .              .                   .                  .                .           
        6,400 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)             0                  0              0               2,400 ( 0.00%)         0                0           int* argmax_batch(float* arr, int size, int batch_size) {
        1,600 ( 0.00%)  0           0                      0                  0              0                 800 ( 0.00%)         0                0               int* idxs = malloc(batch_size * sizeof(int));
        1,600 ( 0.00%)  0           0                      0                  0              0                   0                  0                0               if (!idxs) return NULL;
            .           .           .                      .                  .              .                   .                  .                .           
       12,000 ( 0.00%)  0           0                      0                  0              0                   0                  0                0               for (int b = 0; b < batch_size; b++) {
          800 ( 0.00%)  0           0                    800 ( 0.00%)         0              0                   0                  0                0                   float max_val = arr[b*size +0];
        1,600 ( 0.00%)  0           0                      0                  0              0                   0                  0                0                   int best = 0;
       24,000 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)             0                  0              0                   0                  0                0                   for (int i = 1; i < size; i++) {
        7,200 ( 0.00%)  0           0                  7,200 ( 0.00%)         0              0                   0                  0                0                       if (arr[b*size +i] > max_val) {
       28,800 ( 0.00%)  0           0                      0                  0              0                   0                  0                0                           max_val = arr[b*size +i];
            .           .           .                      .                  .              .                   .                  .                .                           best = i;
            .           .           .                      .                  .              .                   .                  .                .                       }
            .           .           .                      .                  .              .                   .                  .                .                   }
          800 ( 0.00%)  0           0                      0                  0              0                 800 ( 0.00%)         0                0                   idxs[b] = best;
            .           .           .                      .                  .              .                   .                  .                .               }
            .           .           .                      .                  .              .                   .                  .                .               return idxs;
        3,200 ( 0.00%)  0           0                  3,200 ( 0.00%)         0              0                   0                  0                0           }
--------------------------------------------------------------------------------
-- Auto-annotated source: /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/FC_layer.c
--------------------------------------------------------------------------------
Ir                   I1mr        ILmr        Dr                  D1mr                DLmr            Dw                  D1mw             DLmw         

          .           .           .                   .                   .               .                   .                .            .           ﻿#include "main.h"
          .           .           .                   .                   .               .                   .                .            .           #include "feature_map.h"
          .           .           .                   .                   .               .                   .                .            .           
          .           .           .                   .                   .               .                   .                .            .           float **initialize_weight(int input_dim, int output_dim)
          .           .           .                   .                   .               .                   .                .            .           {
          7 ( 0.00%)  2 ( 0.01%)  2 ( 0.08%)          0                   0               0                   3 ( 0.00%)       1 ( 0.00%)   0               float **weight = (float **)malloc(input_dim * sizeof(float *));
      7,692 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)      2,561 ( 0.00%)          0               0                   2 ( 0.00%)       0            0               for (int i = 0; i < input_dim; i++)
          .           .           .                   .                   .               .                   .                .            .               {
     10,240 ( 0.00%)  0           0                   0                   0               0               5,120 ( 0.00%)     320 ( 0.00%) 319 ( 0.02%)          weight[i] = (float *)calloc(output_dim, sizeof(float));
          .           .           .                   .                   .               .                   .                .            .               }
          1 ( 0.00%)  0           0                   1 ( 0.00%)          0               0                   0                0            0               return weight;
          .           .           .                   .                   .               .                   .                .            .           }
          .           .           .                   .                   .               .                   .                .            .           
          .           .           .                   .                   .               .                   .                .            .           float *initialize_bias(int output_dim)
          .           .           .                   .                   .               .                   .                .            .           {
          5 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)          1 ( 0.00%)          0               0                   2 ( 0.00%)       2 ( 0.00%)   0               float *bias = (float *)calloc(output_dim, sizeof(float));
          .           .           .                   .                   .               .                   .                .            .               return bias;
          .           .           .                   .                   .               .                   .                .            .           }
          .           .           .                   .                   .               .                   .                .            .           
          .           .           .                   .                   .               .                   .                .            .           void initialize_FC_layer(FC_layer *layer, float **input, int input_dim, int output_dim, int batch_size, int epoch, int num_train)
      5,016 ( 0.00%)  4 ( 0.03%)  4 ( 0.16%)          0                   0               0               3,344 ( 0.00%)       0            0           {
        418 ( 0.00%)  0           0                   0                   0               0                 418 ( 0.00%)     418 ( 0.00%)   1 ( 0.00%)      layer->input_dim = input_dim;
        418 ( 0.00%)  0           0                   0                   0               0                 418 ( 0.00%)       0            0               layer->output_dim = output_dim;
        418 ( 0.00%)  0           0                   0                   0               0                 418 ( 0.00%)       0            0               layer->input = input;
        836 ( 0.00%)  0           0                 418 ( 0.00%)          0               0                   0                0            0               if (epoch == 0 && num_train == 0)
          .           .           .                   .                   .               .                   .                .            .               {
          8 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)          4 ( 0.00%)          1 ( 0.00%)      1 ( 0.00%)          1 ( 0.00%)       1 ( 0.00%)   0                   layer->weights = initialize_weight(input_dim, output_dim);
      7,682 ( 0.00%)  0           0                   0                   0               0                   0                0            0                   for (int i = 0; i < input_dim; i++)
          .           .           .                   .                   .               .                   .                .            .                   {
     89,600 ( 0.00%)  0           0               2,560 ( 0.00%)        321 ( 0.00%)      0                   0                0            0                       for (int j = 0; j < output_dim; j++)
          .           .           .                   .                   .               .                   .                .            .                       {
     25,600 ( 0.00%)  0           0                   0                   0               0              25,600 ( 0.00%)   1,927 ( 0.02%)   0                           layer->weights[i][j] = 1.0; //((float)rand() / RAND_MAX) * 2 - 1
          .           .           .                   .                   .               .                   .                .            .                       }
          .           .           .                   .                   .               .                   .                .            .                   }
          .           .           .                   .                   .               .                   .                .            .           
          1 ( 0.00%)  0           0                   0                   0               0                   1 ( 0.00%)       1 ( 0.00%)   0                   layer->bias = initialize_bias(output_dim);
          2 ( 0.00%)  0           0                   1 ( 0.00%)          0               0                   1 ( 0.00%)       0            0                   for (int i = 0; i < output_dim; i++)
          .           .           .                   .                   .               .                   .                .            .                   {
          .           .           .                   .                   .               .                   .                .            .                       layer->bias[i] = 0.0; //((float)rand() / RAND_MAX) * 0.01
          .           .           .                   .                   .               .                   .                .            .                   }
          .           .           .                   .                   .               .                   .                .            .                   // cấp phát bộ nhớ cho layer->grad
          5 ( 0.00%)  0           0                   1 ( 0.00%)          0               0                   2 ( 0.00%)       0            0                   layer->grad = (float **)malloc(layer->input_dim * sizeof(float *));
      7,681 ( 0.00%)  0           0                   0                   0               0                   0                0            0                   for (int i = 0; i < layer->input_dim; i++)
          .           .           .                   .                   .               .                   .                .            .                   {
     10,246 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)          1 ( 0.00%)          0               0               5,121 ( 0.00%)     320 ( 0.00%) 319 ( 0.02%)              layer->grad[i] = (float *)calloc(batch_size, sizeof(float));
          .           .           .                   .                   .               .                   .                .            .                   }
          .           .           .                   .                   .               .                   .                .            .                   // cấp phát bộ nhớ cho layer->output
          8 ( 0.00%)  0           0                   1 ( 0.00%)          1 ( 0.00%)      0                   3 ( 0.00%)       1 ( 0.00%)   0                   layer->output = (float **)malloc(output_dim * sizeof(float *));
         36 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)         12 ( 0.00%)          0               0                   0                0            0                   for (int i = 0; i < output_dim; i++)
          .           .           .                   .                   .               .                   .                .            .                   {
         34 ( 0.00%)  0           0                   0                   0               0                  20 ( 0.00%)       1 ( 0.00%)   1 ( 0.00%)              layer->output[i] = (float *)malloc(batch_size * sizeof(float));
          .           .           .                   .                   .               .                   .                .            .                   }
          .           .           .                   .                   .               .                   .                .            .               }
          .           .           .                   .                   .               .                   .                .            .           
      7,526 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)        836 ( 0.00%)          0               0                   0                0            0               for (int b = 0; b < batch_size; b++)
          .           .           .                   .                   .               .                   .                .            .               {
     31,232 ( 0.00%)  0           0                   0                   0               0                   0                0            0                   for (int i = 0; i < output_dim; i++)
          .           .           .                   .                   .               .                   .                .            .                   {
     30,256 ( 0.00%)  0           0              10,736 ( 0.00%)     10,317 ( 0.02%)     36 ( 0.00%)      9,760 ( 0.00%)   9,759 ( 0.09%) 396 ( 0.02%)              layer->output[i][b] = 0.0f;
 74,986,080 ( 0.58%)  0           0                   0                   0               0                   0                0            0                       for (int j = 0; j < input_dim; j++)
          .           .           .                   .                   .               .                   .                .            .                       {
149,962,400 ( 1.16%)  1 ( 0.01%)  1 ( 0.04%) 99,952,160 ( 2.41%) 44,963,818 (69.10%) 37,183 ( 3.33%) 24,985,600 ( 4.06%)       0            0                           layer->output[i][b] += input[j][b] * (layer->weights[j][i]);
          .           .           .                   .                   .               .                   .                .            .                       }
     22,448 ( 0.00%) 18 ( 0.12%) 18 ( 0.71%)     10,736 ( 0.00%)      5,856 ( 0.01%)     34 ( 0.00%)      9,760 ( 0.00%)       0            0                       layer->output[i][b] += layer->bias[i];
          .           .           .                   .                   .               .                   .                .            .                   }
          .           .           .                   .                   .               .                   .                .            .               }
  3,211,076 ( 0.02%)  0           0                   0                   0               0                   0                0            0               for (int i = 0; i < input_dim; i++)
          .           .           .                   .                   .               .                   .                .            .               {
  2,140,160 ( 0.02%)  0           0                   0                   0               0                   0                0            0                   for (int b = 0; b < batch_size; b++)
          .           .           .                   .                   .               .                   .                .            .                   {
  5,353,326 ( 0.04%) 16 ( 0.11%) 16 ( 0.63%)  2,140,578 ( 0.05%)    134,596 ( 0.21%)  5,535 ( 0.50%)  1,070,080 ( 0.17%)     418 ( 0.00%)   0                       layer->grad[i][b] = 0.0f;
          .           .           .                   .                   .               .                   .                .            .                   }
          .           .           .                   .                   .               .                   .                .            .               }
      3,344 ( 0.00%)  0           0               2,926 ( 0.00%)        836 ( 0.00%)      0                   0                0            0           }
          .           .           .                   .                   .               .                   .                .            .           
          .           .           .                   .                   .               .                   .                .            .           
          .           .           .                   .                   .               .                   .                .            .           
          .           .           .                   .                   .               .                   .                .            .           void load_FC_layer_weights(FC_layer* layer, const char* filename) {
          .           .           .                   .                   .               .                   .                .            .               int input_dim = layer->input_dim;
          .           .           .                   .                   .               .                   .                .            .               int output_dim = layer->output_dim;
          .           .           .                   .                   .               .                   .                .            .               layer->weights = initialize_weight(input_dim, output_dim);
          .           .           .                   .                   .               .                   .                .            .               FILE* fp = fopen(filename, "rb");
-- line 82 ----------------------------------------
-- line 237 ----------------------------------------
          .           .           .                   .                   .               .                   .                .            .                   free(dw[i]);
          .           .           .                   .                   .               .                   .                .            .               }
          .           .           .                   .                   .               .                   .                .            .               free(dw);
          .           .           .                   .                   .               .                   .                .            .               free(db);
          .           .           .                   .                   .               .                   .                .            .           }
          .           .           .                   .                   .               .                   .                .            .           
          .           .           .                   .                   .               .                   .                .            .           
          .           .           .                   .                   .               .                   .                .            .           FEATURE_MAP unflatten(float **grad_flatten, int channels, int height, int width, int batch_size)
        324 ( 0.00%)  3 ( 0.02%)  3 ( 0.12%)         18 ( 0.00%)          0               0                 162 ( 0.00%)       0            0           {
        108 ( 0.00%)  0           0                   0                   0               0                  18 ( 0.00%)       0            0               FEATURE_MAP grad_matric = init_feature_map(height, width, channels, batch_size);
      1,782 ( 0.00%)  0           0                 576 ( 0.00%)        576 ( 0.00%)      0                   0                0            0               for (int b = 0; b < batch_size; b++)
          .           .           .                   .                   .               .                   .                .            .               {
        576 ( 0.00%)  0           0                   0                   0               0                   0                0            0                   size_t k = 0;
     20,160 ( 0.00%)  0           0                 576 ( 0.00%)          0               0                   0                0            0                   for (int c = 0; c < channels; c++)
          .           .           .                   .                   .               .                   .                .            .                   {
    293,760 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)          0                   0               0                   0                0            0                       for (int i = 0; i < height; i++)
          .           .           .                   .                   .               .                   .                .            .                       {
  4,608,000 ( 0.04%)  2 ( 0.01%)  2 ( 0.08%)          0                   0               0                   0                0            0                           for (int j = 0; j < width; j++)
          .           .           .                   .                   .               .                   .                .            .                           {
  5,068,944 ( 0.04%)  1 ( 0.01%)  1 ( 0.04%)  3,225,618 ( 0.08%)  1,670,599 ( 2.57%)      0           1,474,578 ( 0.24%) 118,166 ( 1.12%)   0                               grad_matric.fm_value[b][c][i][j] = grad_flatten[k++][b];
          .           .           .                   .                   .               .                   .                .            .                           }
          .           .           .                   .                   .               .                   .                .            .                       }
          .           .           .                   .                   .               .                   .                .            .                   }
          .           .           .                   .                   .               .                   .                .            .               }
         90 ( 0.00%)  0           0                  54 ( 0.00%)         18 ( 0.00%)      0                  36 ( 0.00%)      36 ( 0.00%)   2 ( 0.00%)      return grad_matric;
        216 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)        180 ( 0.00%)         36 ( 0.00%)      0                   0                0            0           }
          .           .           .                   .                   .               .                   .                .            .           
          .           .           .                   .                   .               .                   .                .            .           
          .           .           .                   .                   .               .                   .                .            .           void free_FC_layer(FC_layer *layer)
          5 ( 0.00%)  0           0                   0                   0               0                   2 ( 0.00%)       0            0           {
          2 ( 0.00%)  0           0                   0                   0               0                   0                0            0               if (layer == NULL)
          .           .           .                   .                   .               .                   .                .            .                   return;
          .           .           .                   .                   .               .                   .                .            .           
      7,685 ( 0.00%)  0           0               2,561 ( 0.00%)          2 ( 0.00%)      0                   0                0            0               for (int i = 0; i < layer->input_dim; i++)
          .           .           .                   .                   .               .                   .                .            .               {
      7,680 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)      5,120 ( 0.00%)        321 ( 0.00%)      0               2,560 ( 0.00%)       0            0                   free(layer->weights[i]);
      7,680 ( 0.00%)  0           0               5,120 ( 0.00%)        322 ( 0.00%)      0               2,560 ( 0.00%)       0            0                   free(layer->grad[i]);
          .           .           .                   .                   .               .                   .                .            .               }
         35 ( 0.00%)  0           0                  11 ( 0.00%)          0               0                   0                0            0               for (int j = 0; j < layer->output_dim; j++)
          .           .           .                   .                   .               .                   .                .            .               {
         30 ( 0.00%)  1 ( 0.01%)  1 ( 0.04%)         20 ( 0.00%)          1 ( 0.00%)      0                  10 ( 0.00%)       0            0                   free(layer->output[j]);
          .           .           .                   .                   .               .                   .                .            .               }
          2 ( 0.00%)  0           0                   1 ( 0.00%)          0               0                   1 ( 0.00%)       0            0               free(layer->weights);
          2 ( 0.00%)  0           0                   1 ( 0.00%)          0               0                   1 ( 0.00%)       0            0               free(layer->bias);
          2 ( 0.00%)  0           0                   1 ( 0.00%)          0               0                   1 ( 0.00%)       0            0               free(layer->output);
          2 ( 0.00%)  0           0                   1 ( 0.00%)          0               0                   0                0            0               free(layer->grad);
          3 ( 0.00%)  0           0                   2 ( 0.00%)          0               0                   0                0            0           }
          .           .           .                   .                   .               .                   .                .            .           

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/load_file.c
--------------------------------------------------------------------------------
Ir                  I1mr         ILmr       Dr                 D1mr           DLmr       Dw             D1mw         DLmw         

         .            .          .                  .              .          .              .            .            .           #include "main.h"
         .            .          .                  .              .          .              .            .            .           
   536,800 ( 0.00%)   2 ( 0.01%) 2 ( 0.08%)         0              0          0          3,416 ( 0.00%)   0            0           void load_feature_map_from_bin(FEATURE_MAP* fm, const char* filename, int number) {
       976 ( 0.00%)   0          0                  0              0          0            488 ( 0.00%)   0            0               FILE* fp = fopen(filename, "rb");
     1,464 ( 0.00%)   0          0                  0              0          0              0            0            0               if (fp == NULL) {
         .            .          .                  .              .          .              .            .            .                   printf("Error: Cannot open feature map file %s\n", filename);
         .            .          .                  .              .          .              .            .            .                   exit(1);
         .            .          .                  .              .          .              .            .            .               }
         .            .          .                  .              .          .              .            .            .               //printf("file: %s\n", filename);
    46,848 ( 0.00%)   1 ( 0.01%) 1 ( 0.04%)         0              0          0              0            0            0               for (int i = 0; i < INPUT_SIZE; i++) {
 1,499,136 ( 0.01%)   0          0                  0              0          0              0            0            0                   for (int j = 0; j < INPUT_SIZE; j++) {
 4,497,408 ( 0.03%)   0          0                  0              0          0              0            0            0                       for (int c = 0; c < INPUT_CHANNEL; c++) {
         .            .          .                  .              .          .              .            .            .                           //printf("c: %d\n", c);
         .            .          .                  .              .          .              .            .            .                           //printf("number c i j: %d %d %d %d", number, c, i, j);
10,494,928 ( 0.08%)   0          0          5,996,544 ( 0.14%) 3,714 ( 0.01%) 0              0            0            0                           if (fread(&fm->fm_value[number][c][i][j], sizeof(float), 1, fp) != 1) {
         .            .          .                  .              .          .              .            .            .                               printf("Error: Failed to read feature map from file %s\n", filename);
         .            .          .                  .              .          .              .            .            .                               fclose(fp);
         .            .          .                  .              .          .              .            .            .                               exit(1);
         .            .          .                  .              .          .              .            .            .                           }
         .            .          .                  .              .          .              .            .            .                           //printf("fm[%d][%d][%d][%d]: %f\n", number, c, i, j, fm->fm_value[number][c][i][j]);
         .            .          .                  .              .          .              .            .            .                       }
         .            .          .                  .              .          .              .            .            .                   }
         .            .          .                  .              .          .              .            .            .               }
       976 ( 0.00%)   0          0                  0              0          0              0            0            0               fclose(fp);
     3,416 ( 0.00%)   0          0              2,928 ( 0.00%)     0          0              0            0            0           }
         .            .          .                  .              .          .              .            .            .           
     5,292 ( 0.00%) 590 ( 4.00%) 2 ( 0.08%)         0              0          0          3,528 ( 0.00%)   0            0           int* load_label_from_txt(const char* filename) {
     1,176 ( 0.00%)   0          0                  0              0          0            588 ( 0.00%)   0            0               FILE* fp = fopen(filename, "r");
     1,176 ( 0.00%)   0          0                  0              0          0              0            0            0               if (fp == NULL) {
         .            .          .                  .              .          .              .            .            .                   perror("Fail to open label file");
         .            .          .                  .              .          .              .            .            .                   exit(EXIT_FAILURE);
         .            .          .                  .              .          .              .            .            .               }
         .            .          .                  .              .          .              .            .            .           
     2,352 ( 0.00%)   0          0                  0              0          0            588 ( 0.00%)   0            0               int* label_row = (int*)malloc(NUM_CLASSES * sizeof(int));
     1,764 ( 0.00%)   0          0                  0              0          0              0            0            0               if (label_row == NULL) {
         .            .          .                  .              .          .              .            .            .                   perror("Fail to allocate memory");
         .            .          .                  .              .          .              .            .            .                   fclose(fp);
         .            .          .                  .              .          .              .            .            .                   exit(EXIT_FAILURE);
         .            .          .                  .              .          .              .            .            .               }
         .            .          .                  .              .          .              .            .            .           
    24,696 ( 0.00%)   0          0                  0              0          0              0            0            0               for (int i = 0; i < NUM_CLASSES; i++) {
    41,160 ( 0.00%)   1 ( 0.01%) 1 ( 0.04%)         0              0          0          5,880 ( 0.00%)   0            0                   if (fscanf(fp, "%d", &label_row[i]) != 1) {
         .            .          .                  .              .          .              .            .            .                       fprintf(stderr, "Error label %d từ %s\n", i, filename);
         .            .          .                  .              .          .              .            .            .                       fclose(fp);
         .            .          .                  .              .          .              .            .            .                       free(label_row);
         .            .          .                  .              .          .              .            .            .                       exit(EXIT_FAILURE);
         .            .          .                  .              .          .              .            .            .                   }
         .            .          .                  .              .          .              .            .            .               }
         .            .          .                  .              .          .              .            .            .           
     1,176 ( 0.00%)   0          0                  0              0          0            588 ( 0.00%)   0            0               fclose(fp);
         .            .          .                  .              .          .              .            .            .               return label_row;
     5,292 ( 0.00%)   0          0              4,116 ( 0.00%)     0          0              0            0            0           }
         .            .          .                  .              .          .              .            .            .           
        13 ( 0.00%)   1 ( 0.01%) 1 ( 0.04%)         1 ( 0.00%)     0          0              7 ( 0.00%)   0            0           int** load_all_train_labels(int num_samples, const char* label_folder) { 
         3 ( 0.00%)   1 ( 0.01%) 1 ( 0.04%)         0              0          0              2 ( 0.00%)   0            0               int** labels = (int**)malloc(num_samples * sizeof(int*));  // mình đang cần trải phảng hết ra giống như trong hàm sofmax và crossentrop
         2 ( 0.00%)   0          0                  0              0          0              0            0            0               if (labels == NULL) {
         .            .          .                  .              .          .              .            .            .                   perror("Fail to alocate memory");
         .            .          .                  .              .          .              .            .            .                   exit(EXIT_FAILURE);
         .            .          .                  .              .          .              .            .            .               }
         .            .          .                  .              .          .              .            .            .           
         .            .          .                  .              .          .              .            .            .               char filename[256];
         .            .          .                  .              .          .              .            .            .           
       872 ( 0.00%)   2 ( 0.01%) 2 ( 0.08%)         1 ( 0.00%)     0          0              0            0            0               for (int i = 0; i < num_samples; i++) {
         .            .          .                  .              .          .              .            .            .                   sprintf(filename, "%slabel_train_%d.txt", label_folder, i);
         .            .          .                  .              .          .              .            .            .                   //printf("%s\n", filename);
       864 ( 0.00%)   0          0                  0              0          0            576 ( 0.00%)   0            0                   labels[i] = load_label_from_txt(filename);
         .            .          .                  .              .          .              .            .            .                   //printf("Đã load label: %s\n", filename);
         .            .          .                  .              .          .              .            .            .               }
         .            .          .                  .              .          .              .            .            .           
         .            .          .                  .              .          .              .            .            .               return labels;
        12 ( 0.00%)   0          0                  9 ( 0.00%)     0          0              0            0            0           }
         .            .          .                  .              .          .              .            .            .           
        13 ( 0.00%)   2 ( 0.01%) 2 ( 0.08%)         1 ( 0.00%)     0          0              7 ( 0.00%)   0            0           int** load_all_valid_labels(int num_samples, const char* label_folder) {
         3 ( 0.00%)   0          0                  0              0          0              2 ( 0.00%)   0            0               int** labels = (int**)malloc(num_samples * sizeof(int*));  // tại sao lại cấp phát mảng 2 chiều => chưa cấp phát chiều còn lại=> mình đang cần trải phảng hết ra giống như trong hàm sofmax và crossentropy
         2 ( 0.00%)   0          0                  0              0          0              0            0            0               if (labels == NULL) {
         .            .          .                  .              .          .              .            .            .                   perror("Fail to alocate memory");
         .            .          .                  .              .          .              .            .            .                   exit(EXIT_FAILURE);
         .            .          .                  .              .          .              .            .            .               }
         .            .          .                  .              .          .              .            .            .           
         .            .          .                  .              .          .              .            .            .               char filename[256];
         .            .          .                  .              .          .              .            .            .           
       608 ( 0.00%)   0          0                  1 ( 0.00%)     0          0              0            0            0               for (int i = 0; i < num_samples; i++) {
         .            .          .                  .              .          .              .            .            .                   sprintf(filename,  "%slabel_train_%d.txt", label_folder, i+NUM_TRAIN);
         .            .          .                  .              .          .              .            .            .                   //printf("%s\n", filename);
       600 ( 0.00%)   0          0                  0              0          0            400 ( 0.00%)   0            0                   labels[i] = load_label_from_txt(filename);
         .            .          .                  .              .          .              .            .            .                   //printf("Đã load label: %s\n", filename);
         .            .          .                  .              .          .              .            .            .               }
         .            .          .                  .              .          .              .            .            .           
         .            .          .                  .              .          .              .            .            .               return labels;
        12 ( 0.00%)   1 ( 0.01%) 1 ( 0.04%)         9 ( 0.00%)     0          0              0            0            0           }
         .            .          .                  .              .          .              .            .            .           
        13 ( 0.00%)   0          0                  1 ( 0.00%)     0          0              7 ( 0.00%)   0            0           int** load_all_test_labels(int num_samples, const char* label_folder) {
         3 ( 0.00%)   1 ( 0.01%) 1 ( 0.04%)         0              0          0              2 ( 0.00%)   0            0               int** labels = (int**)malloc(num_samples * sizeof(int*)); // tại sao lại cấp phát mảng 2 chiều => chưa cấp phát chiều còn lại=> mình đang cần trải phảng hết ra giống như trong hàm sofmax và crossentrop
         2 ( 0.00%)   0          0                  0              0          0              0            0            0               if (labels == NULL) {
         .            .          .                  .              .          .              .            .            .                   perror("Fail to alocate memory");
         .            .          .                  .              .          .              .            .            .                   exit(EXIT_FAILURE);
         .            .          .                  .              .          .              .            .            .               }
         .            .          .                  .              .          .              .            .            .           
         .            .          .                  .              .          .              .            .            .               char filename[256];
         .            .          .                  .              .          .              .            .            .           
       308 ( 0.00%)   2 ( 0.01%) 2 ( 0.08%)         1 ( 0.00%)     0          0              0            0            0               for (int i = 0; i < num_samples; i++) {
         .            .          .                  .              .          .              .            .            .                   sprintf(filename,  "%slabel_test_%d.txt", label_folder, i);
         .            .          .                  .              .          .              .            .            .                   //printf("%s\n", filename);
       300 ( 0.00%)   0          0                  0              0          0            200 ( 0.00%)   0            0                   labels[i] = load_label_from_txt(filename);
         .            .          .                  .              .          .              .            .            .                   //printf("Đã load label: %s\n", filename);
         .            .          .                  .              .          .              .            .            .               }
         .            .          .                  .              .          .              .            .            .           
         .            .          .                  .              .          .              .            .            .               return labels;
        12 ( 0.00%)   0          0                  9 ( 0.00%)     0          0              0            0            0           }
         .            .          .                  .              .          .              .            .            .           
     3,344 ( 0.00%)   2 ( 0.01%) 2 ( 0.08%)       209 ( 0.00%)     0          0          1,672 ( 0.00%)   0            0           void load_all_train_data(FEATURE_MAP* train_samples, const char* img_folder, int* count, int batch_size) {
         .            .          .                  .              .          .              .            .            .               char filename[256];
     2,090 ( 0.00%)   0          0                418 ( 0.00%)     0          0            627 ( 0.00%)  86 ( 0.00%)  77 ( 0.00%)      (*train_samples) = init_feature_map(32, 32, 3, batch_size);
     2,718 ( 0.00%)   1 ( 0.01%) 1 ( 0.04%)       488 ( 0.00%)     0          0              0            0            0               for (int i = 0; i < batch_size; i++) {
         .            .          .                  .              .          .              .            .            .                   //printf("i: %d\n", i);
       209 ( 0.00%)   0          0                209 ( 0.00%)     9 ( 0.00%) 0              0            0            0                   sprintf(filename, "%strain_img_%d.bin", img_folder, (*count));
     1,952 ( 0.00%)   0          0                  0              0          0            488 ( 0.00%)   0            0                   load_feature_map_from_bin(train_samples, filename, i);
     1,464 ( 0.00%)   1 ( 0.01%) 1 ( 0.04%)       488 ( 0.00%)     0          0            488 ( 0.00%)   0            0                   (*count)++;
         .            .          .                  .              .          .              .            .            .               }
     2,299 ( 0.00%)   0          0              1,881 ( 0.00%)    18 ( 0.00%) 0              0            0            0           }
         .            .          .                  .              .          .              .            .            .           
         .            .          .                  .              .          .              .            .            .           void load_all_train_data_res(FEATURE_MAP* train_samples, const char* img_folder, int* count) {
         .            .          .                  .              .          .              .            .            .               char filename[256];
         .            .          .                  .              .          .              .            .            .               int res = NUM_TRAIN - NUM_MINI_BATCH * BATCH_SIZE;
         .            .          .                  .              .          .              .            .            .               (*train_samples) = init_feature_map(32, 32, 3, res);
         .            .          .                  .              .          .              .            .            .               for (int i = 0; i < res; i++) {
         .            .          .                  .              .          .              .            .            .                   //printf("i: %d\n", i);
         .            .          .                  .              .          .              .            .            .                   sprintf(filename, "%strain_img_%d.bin", img_folder, (*count));
-- line 128 ----------------------------------------
-- line 185 ----------------------------------------
         .            .          .                  .              .          .              .            .            .                       free(bias);
         .            .          .                  .              .          .              .            .            .                       exit(1);
         .            .          .                  .              .          .              .            .            .                   }
         .            .          .                  .              .          .              .            .            .               }
         .            .          .                  .              .          .              .            .            .               fclose(file);
         .            .          .                  .              .          .              .            .            .               return bias;
         .            .          .                  .              .          .              .            .            .           }
         .            .          .                  .              .          .              .            .            .           
        21 ( 0.00%)   1 ( 0.01%) 1 ( 0.04%)         0              0          0              9 ( 0.00%)   0            0           int *flatten_label(int **load_label, int num_sample, int num_of_category){
        15 ( 0.00%)   1 ( 0.01%) 1 ( 0.04%)         0              0          0              3 ( 0.00%)   0            0               int *y= (int*) malloc(num_sample*num_of_category*sizeof(int));
         .            .          .                  .              .          .              .            .            .           
         6 ( 0.00%)   0          0                  0              0          0              0            0            0               if(load_label==NULL){
         .            .          .                  .              .          .              .            .            .                   return NULL;
         .            .          .                  .              .          .              .            .            .               }
         .            .          .                  .              .          .              .            .            .           
     2,376 ( 0.00%)   0          0                  0              0          0              0            0            0               for(int i=0; i<num_sample; i++){
    25,284 ( 0.00%)   1 ( 0.01%) 1 ( 0.04%)         0              0          0              0            0            0                   for(int j=0; j<num_of_category; j++){
    13,524 ( 0.00%)   0          0              6,468 ( 0.00%)   229 ( 0.00%) 0          5,880 ( 0.00%) 301 ( 0.00%) 301 ( 0.02%)              y[i*num_of_category+j]= load_label[i][j];
         .            .          .                  .              .          .              .            .            .                   }
         .            .          .                  .              .          .              .            .            .               }
         .            .          .                  .              .          .              .            .            .               return y;
        12 ( 0.00%)   0          0                 12 ( 0.00%)     0          0              0            0            0           }
         .            .          .                  .              .          .              .            .            .           
        15 ( 0.00%)   0          0                  0              0          0              9 ( 0.00%)   0            0           void free_label(int **label_2d, int num_sample){
     1,782 ( 0.00%)   0          0                  0              0          0              0            0            0               for(int i=0; i< num_sample; i++){
     1,176 ( 0.00%)   1 ( 0.01%) 1 ( 0.04%)       588 ( 0.00%)    20 ( 0.00%) 0            588 ( 0.00%)   0            0                   free(label_2d[i]);
         .            .          .                  .              .          .              .            .            .               }
         6 ( 0.00%)   0          0                  0              0          0              0            0            0               free(label_2d);
         9 ( 0.00%)   0          0                  9 ( 0.00%)     0          0              0            0            0           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/haiduong/EDABK/EDABK_project1_CNN/Code_CNN_ver4/Code_CNN_batch/feature_map.c
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                 D1mr             DLmr             Dw                 D1mw             DLmw            

         .          .          .                  .                .                .                  .                .               .           ﻿#include "main.h"
         .          .          .                  .                .                .                  .                .               .           
         .          .          .                  .                .                .                  .                .               .           FEATURE_MAP init_feature_map(int height, int width, int channels, int batch_size)
    29,295 ( 0.00%) 2 ( 0.01%) 2 ( 0.08%)         0                0                0             19,530 ( 0.00%)     871 ( 0.01%)      4 ( 0.00%)  {
         .          .          .                  .                .                .                  .                .               .               FEATURE_MAP feature_map;
         .          .          .                  .                .                .                  .                .               .               feature_map.batch_size = batch_size;
         .          .          .                  .                .                .                  .                .               .               feature_map.height = height;
         .          .          .                  .                .                .                  .                .               .               feature_map.width = width;
         .          .          .                  .                .                .                  .                .               .               feature_map.channels = channels;
         .          .          .                  .                .                .                  .                .               .           
     5,859 ( 0.00%) 0          0                  0                0                0              3,906 ( 0.00%)     854 ( 0.01%)      5 ( 0.00%)      feature_map.fm_value = (float ****)malloc(batch_size * sizeof(float ***));
    30,690 ( 0.00%) 0          0             20,088 ( 0.00%)   1,552 ( 0.00%)       0                  0                0               0               for (int b = 0; b < batch_size; b++)
         .          .          .                  .                .                .                  .                .               .               {
    64,728 ( 0.00%) 2 ( 0.01%) 2 ( 0.08%)    19,251 ( 0.00%)       0                0             23,157 ( 0.00%)   1,544 ( 0.01%)    169 ( 0.01%)          feature_map.fm_value[b] = (float ***)malloc(channels * sizeof(float **));
   240,696 ( 0.00%) 0          0             84,696 ( 0.00%)       0                0                  0                0               0                   for (int c = 0; c < channels; c++)
         .          .          .                  .                .                .                  .                .               .                   {
   289,122 ( 0.00%) 0          0                  0                0                0            142,608 ( 0.02%)   4,201 ( 0.04%)  1,007 ( 0.06%)              feature_map.fm_value[b][c] = (float **)malloc(height * sizeof(float *));
 5,292,744 ( 0.04%) 0          0             71,304 ( 0.00%)       0                0                  0                0               0                       for (int h = 0; h < height; h++)
         .          .          .                  .                .                .                  .                .               .                       {
 6,608,416 ( 0.05%) 1 ( 0.01%) 1 ( 0.04%)     6,696 ( 0.00%)       0                0          3,297,512 ( 0.54%) 123,151 ( 1.17%) 52,983 ( 3.01%)                  feature_map.fm_value[b][c][h] = (float *)calloc(width ,sizeof(float));
         .          .          .                  .                .                .                  .                .               .                           
         .          .          .                  .                .                .                  .                .               .                       }
         .          .          .                  .                .                .                  .                .               .                   }
         .          .          .                  .                .                .                  .                .               .               }
         .          .          .                  .                .                .                  .                .               .           
    19,530 ( 0.00%) 1 ( 0.01%) 1 ( 0.04%)     9,765 ( 0.00%)       0                0              9,765 ( 0.00%)     571 ( 0.01%)      0               return feature_map;
    15,624 ( 0.00%) 0          0             13,671 ( 0.00%)     553 ( 0.00%)       0                  0                0               0           }
         .          .          .                  .                .                .                  .                .               .           
         .          .          .                  .                .                .                  .                .               .           void initialize_input_values(FEATURE_MAP *input)
         .          .          .                  .                .                .                  .                .               .           {
         .          .          .                  .                .                .                  .                .               .               for (int b = 0; b < input->batch_size; b++)
         .          .          .                  .                .                .                  .                .               .               {
         .          .          .                  .                .                .                  .                .               .                   for (int c = 0; c < input->channels; c++)
         .          .          .                  .                .                .                  .                .               .                   {
         .          .          .                  .                .                .                  .                .               .                       for (int i = 0; i < input->height; i++)
-- line 35 ----------------------------------------
-- line 74 ----------------------------------------
         .          .          .                  .                .                .                  .                .               .                   }
         .          .          .                  .                .                .                  .                .               .                   free(input->fm_value[channel]);
         .          .          .                  .                .                .                  .                .               .               }
         .          .          .                  .                .                .                  .                .               .               free(input->fm_value);
         .          .          .                  .                .                .                  .                .               .           }
         .          .          .                  .                .                .                  .                .               .           */
         .          .          .                  .                .                .                  .                .               .           
         .          .          .                  .                .                .                  .                .               .           void free_feature_map(FEATURE_MAP *input)
    19,530 ( 0.00%) 2 ( 0.01%) 2 ( 0.08%)         0                0                0             11,718 ( 0.00%)       0               0           {
    27,900 ( 0.00%) 0          0              8,649 ( 0.00%)   1,319 ( 0.00%)       9 ( 0.00%)         0                0               0               for (int batch_size = 0; batch_size < input->batch_size; batch_size++)
         .          .          .                  .                .                .                  .                .               .               {
   254,088 ( 0.00%) 0          0             78,000 ( 0.00%)      63 ( 0.00%)       1 ( 0.00%)         0                0               0                   for (int channel = 0; channel < input->channels; channel++)
         .          .          .                  .                .                .                  .                .               .                   {
 5,364,048 ( 0.04%) 1 ( 0.01%) 1 ( 0.04%) 1,716,712 ( 0.04%)       0                0                  0                0               0                       for (int h = 0; h < input->height; h++)
         .          .          .                  .                .                .                  .                .               .                       {
 8,227,040 ( 0.06%) 0          0          6,581,632 ( 0.16%) 168,256 ( 0.26%)  41,098 ( 3.68%) 1,645,408 ( 0.27%)     418 ( 0.00%)      0                           free(input->fm_value[batch_size][channel][h]);
         .          .          .                  .                .                .                  .                .               .                       }
   285,216 ( 0.00%) 0          0            213,912 ( 0.01%)       0                0             71,304 ( 0.01%)       0               0                       free(input->fm_value[batch_size][channel]);
         .          .          .                  .                .                .                  .                .               .                   }
    20,088 ( 0.00%) 0          0             13,392 ( 0.00%)       0                0              6,696 ( 0.00%)       0               0                   free(input->fm_value[batch_size]);
         .          .          .                  .                .                .                  .                .               .               }
     3,906 ( 0.00%) 0          0              1,953 ( 0.00%)       2 ( 0.00%)       0                  0                0               0               free(input->fm_value);
    13,671 ( 0.00%) 0          0             11,718 ( 0.00%)     298 ( 0.00%)       0                  0                0               0           }
         .          .          .                  .                .                .                  .                .               .           
         .          .          .                  .                .                .                  .                .               .           FEATURE_MAP padding_feature_map(FEATURE_MAP input, int padding)
     5,232 ( 0.00%) 2 ( 0.01%) 2 ( 0.08%)       872 ( 0.00%)       0                0              3,488 ( 0.00%)     870 ( 0.01%)      6 ( 0.00%)  {
         .          .          .                  .                .                .                  .                .               .               //print_feature_map_values(&input, "input");
     1,308 ( 0.00%) 0          0                  0                0                0                436 ( 0.00%)       0               0               int padding_height = input.height + 2 * padding;
       872 ( 0.00%) 0          0                  0                0                0                436 ( 0.00%)       0               0               int padding_width = input.width + 2 * padding;
     6,104 ( 0.00%) 1 ( 0.01%) 1 ( 0.04%)     2,616 ( 0.00%)       0                0              2,616 ( 0.00%)     435 ( 0.00%)      9 ( 0.00%)      FEATURE_MAP ifm_pad = init_feature_map(padding_height, padding_width, input.channels, input.batch_size);
         .          .          .                  .                .                .                  .                .               .           
     6,836 ( 0.00%) 0          0              2,860 ( 0.00%)       0                0                  0                0               0               for (int b = 0; b < ifm_pad.batch_size; b++) 
         .          .          .                  .                .                .                  .                .               .               {
    21,728 ( 0.00%) 1 ( 0.01%) 1 ( 0.04%)     6,208 ( 0.00%)       0                0                  0                0               0                   for (int c = 0; c < ifm_pad.channels; c++)
         .          .          .                  .                .                .                  .                .               .                   {
   498,192 ( 0.00%) 1 ( 0.01%) 1 ( 0.04%)     4,656 ( 0.00%)       0                0                  0                0               0                       for (int i = 0; i < padding_height; i++)
         .          .          .                  .                .                .                  .                .               .                       {
   316,608 ( 0.00%) 0          0                  0                0                0                  0                0               0                           for (int j = 0; j < padding_width; j++)
         .          .          .                  .                .                .                  .                .               .                           {
   955,928 ( 0.01%) 1 ( 0.01%) 1 ( 0.04%)   475,784 ( 0.01%)  14,053 ( 0.02%)       0            159,612 ( 0.03%)       0               0                               ifm_pad.fm_value[b][c][i][j] = 0;
         .          .          .                  .                .                .                  .                .               .                           }
         .          .          .                  .                .                .                  .                .               .                       }
         .          .          .                  .                .                .                  .                .               .                   }
         .          .          .                  .                .                .                  .                .               .               }
         .          .          .                  .                .                .                  .                .               .           
     4,656 ( 0.00%) 0          0              1,552 ( 0.00%)       0                0                  0                0               0               for (int b = 0; b < ifm_pad.batch_size; b++)
         .          .          .                  .                .                .                  .                .               .               {
    21,728 ( 0.00%) 0          0              1,552 ( 0.00%)       0                0                  0                0               0                   for (int c = 0; c < input.channels; c++)
         .          .          .                  .                .                .                  .                .               .                   {
   619,248 ( 0.00%) 0          0              4,656 ( 0.00%)       0                0                  0                0               0                       for (int i = 0; i < input.height; i++)
         .          .          .                  .                .                .                  .                .               .                       {
14,601,216 ( 0.11%) 1 ( 0.01%) 1 ( 0.04%)         0                0                0                  0                0               0                           for (int j = 0; j < input.width; j++)
         .          .          .                  .                .                .                  .                .               .                           {
11,478,488 ( 0.09%) 2 ( 0.01%) 2 ( 0.08%) 5,812,868 ( 0.14%) 374,702 ( 0.58%) 348,948 (31.25%) 4,917,172 ( 0.80%) 251,593 ( 2.38%)      0                               ifm_pad.fm_value[b][c][i + padding][j + padding] = input.fm_value[b][c][i][j];
         .          .          .                  .                .                .                  .                .               .                           }
         .          .          .                  .                .                .                  .                .               .                       }
         .          .          .                  .                .                .                  .                .               .                   }
         .          .          .                  .                .                .                  .                .               .               }
     2,180 ( 0.00%) 1 ( 0.01%) 0              1,308 ( 0.00%)      41 ( 0.00%)       0                872 ( 0.00%)      55 ( 0.00%)      2 ( 0.00%)      return ifm_pad;
     5,232 ( 0.00%) 0          0              4,360 ( 0.00%)      75 ( 0.00%)       1 ( 0.00%)         0                0               0           }
         .          .          .                  .                .                .                  .                .               .           
         .          .          .                  .                .                .                  .                .               .           /*FEATURE_MAP *init_feature_map_array(int num, int height, int width, int channels)
         .          .          .                  .                .                .                  .                .               .           {
         .          .          .                  .                .                .                  .                .               .               FEATURE_MAP *array = (FEATURE_MAP *)malloc(num * sizeof(FEATURE_MAP));
         .          .          .                  .                .                .                  .                .               .               for (int i = 0; i < num; i++)
         .          .          .                  .                .                .                  .                .               .               {
         .          .          .                  .                .                .                  .                .               .                   array[i] = init_feature_map(height, width, channels);
         .          .          .                  .                .                .                  .                .               .                   initialize_input_values(&array[i]);
-- line 141 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./libio/./libio/fileops.c
  ./libio/./libio/iofread.c
  ./libio/./libio/libioP.h
  ./malloc/./malloc/malloc.c
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
Ir                      I1mr         ILmr         Dr                     D1mr                DLmr             Dw                   D1mw               DLmw             
--------------------------------------------------------------------------------
11,482,890,920 (89.12%) 915 ( 6.21%) 326 (12.93%) 3,804,458,399 (91.92%) 60,707,032 (93.30%) 554,311 (49.64%) 397,306,472 (64.61%) 5,417,530 (51.31%) 267,219 (15.18%)  events annotated

